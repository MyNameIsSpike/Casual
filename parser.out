Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration program
Rule 2     program -> definition program
Rule 3     program -> empty
Rule 4     declaration -> DECL ID LPAREN function_args RPAREN COLON return_type
Rule 5     definition -> DEF ID LPAREN function_args RPAREN COLON return_type block
Rule 6     function_args -> ID COLON var_type function_args
Rule 7     function_args -> COMMA function_args
Rule 8     function_args -> empty
Rule 9     return_type -> INT
Rule 10    return_type -> FLOAT
Rule 11    return_type -> STRING
Rule 12    return_type -> BOOLEAN
Rule 13    return_type -> VOID
Rule 14    block -> LBRACE recursive_statement RBRACE
Rule 15    recursive_statement -> statement recursive_statement
Rule 16    recursive_statement -> empty
Rule 17    statement -> return_statement
Rule 18    statement -> expression SEMI
Rule 19    statement -> if_statement
Rule 20    statement -> while_statement
Rule 21    statement -> variable_declaration
Rule 22    statement -> variable_assignment
Rule 23    return_statement -> RETURN ret_value SEMI
Rule 24    ret_value -> expression
Rule 25    ret_value -> empty
Rule 26    if_statement -> IF expression block else_statement
Rule 27    else_statement -> ELSE block
Rule 28    else_statement -> empty
Rule 29    while_statement -> WHILE expression block
Rule 30    variable_declaration -> ID COLON var_type EQUALS expression SEMI
Rule 31    variable_assignment -> ID EQUALS expression SEMI
Rule 32    var_type -> FLOAT
Rule 33    var_type -> INT
Rule 34    var_type -> STRING
Rule 35    var_type -> BOOLEAN
Rule 36    expression -> expression_binary_operation
Rule 37    expression -> expression_variable
Rule 38    expression -> expression_unary_operation
Rule 39    expression -> expression_literal
Rule 40    expression -> function_invocation
Rule 41    expression -> index_access
Rule 42    expression_binary_operation -> expression PLUS expression
Rule 43    expression_binary_operation -> expression MINUS expression
Rule 44    expression_binary_operation -> expression TIMES expression
Rule 45    expression_binary_operation -> expression DIVIDE expression
Rule 46    expression_binary_operation -> expression MOD expression
Rule 47    expression_binary_operation -> expression AND expression
Rule 48    expression_binary_operation -> expression OR expression
Rule 49    expression_binary_operation -> expression LT expression
Rule 50    expression_binary_operation -> expression GT expression
Rule 51    expression_binary_operation -> expression LE expression
Rule 52    expression_binary_operation -> expression GE expression
Rule 53    expression_binary_operation -> expression EQ expression
Rule 54    expression_binary_operation -> expression NEQ expression
Rule 55    expression_variable -> ID
Rule 56    expression_unary_operation -> NOT expression
Rule 57    expression_literal -> FLOAT_LITERAL
Rule 58    expression_literal -> INT_LITERAL
Rule 59    expression_literal -> STRING_LITERAL
Rule 60    expression_literal -> BOOLEAN_LITERAL
Rule 61    function_invocation -> ID LPAREN func_invocation_args RPAREN
Rule 62    func_invocation_args -> expression func_invocation_args
Rule 63    func_invocation_args -> COMMA func_invocation_args
Rule 64    func_invocation_args -> empty
Rule 65    index_access -> ID index_access_aux
Rule 66    index_access_aux -> LBRACKET expression RBRACKET
Rule 67    index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET
Rule 68    empty -> <empty>

Terminals, with rules where they appear

AND                  : 47
BOOLEAN              : 12 35
BOOLEAN_LITERAL      : 60
COLON                : 4 5 6 30
COMMA                : 7 63
DECL                 : 4
DEF                  : 5
DIVIDE               : 45
ELSE                 : 27
EQ                   : 53
EQUALS               : 30 31
FLOAT                : 10 32
FLOAT_LITERAL        : 57
GE                   : 52
GT                   : 50
ID                   : 4 5 6 30 31 55 61 65
IF                   : 26
INT                  : 9 33
INT_LITERAL          : 58
LBRACE               : 14
LBRACKET             : 66 67
LE                   : 51
LPAREN               : 4 5 61 67
LT                   : 49
MINUS                : 43
MOD                  : 46
NEQ                  : 54
NOT                  : 56
OR                   : 48
PLUS                 : 42
RBRACE               : 14
RBRACKET             : 66 67
RETURN               : 23
RPAREN               : 4 5 61 67
SEMI                 : 18 23 30 31
STRING               : 11 34
STRING_LITERAL       : 59
TIMES                : 44
VOID                 : 13
WHILE                : 29
error                : 

Nonterminals, with rules where they appear

block                : 5 26 27 29
declaration          : 1
definition           : 2
else_statement       : 26
empty                : 3 8 16 25 28 64
expression           : 18 24 26 29 30 31 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 56 62 66 67
expression_binary_operation : 36
expression_literal   : 39
expression_unary_operation : 38
expression_variable  : 37
func_invocation_args : 61 62 63 67
function_args        : 4 5 6 7
function_invocation  : 40
if_statement         : 19
index_access         : 41
index_access_aux     : 65
program              : 1 2 0
recursive_statement  : 14 15
ret_value            : 23
return_statement     : 17
return_type          : 4 5
statement            : 15
var_type             : 6 30
variable_assignment  : 22
variable_declaration : 21
while_statement      : 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration program
    (2) program -> . definition program
    (3) program -> . empty
    (4) declaration -> . DECL ID LPAREN function_args RPAREN COLON return_type
    (5) definition -> . DEF ID LPAREN function_args RPAREN COLON return_type block
    (68) empty -> .

    DECL            shift and go to state 5
    DEF             shift and go to state 6
    $end            reduce using rule 68 (empty -> .)

    program                        shift and go to state 1
    declaration                    shift and go to state 2
    definition                     shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration . program
    (1) program -> . declaration program
    (2) program -> . definition program
    (3) program -> . empty
    (4) declaration -> . DECL ID LPAREN function_args RPAREN COLON return_type
    (5) definition -> . DEF ID LPAREN function_args RPAREN COLON return_type block
    (68) empty -> .

    DECL            shift and go to state 5
    DEF             shift and go to state 6
    $end            reduce using rule 68 (empty -> .)

    declaration                    shift and go to state 2
    program                        shift and go to state 7
    definition                     shift and go to state 3
    empty                          shift and go to state 4

state 3

    (2) program -> definition . program
    (1) program -> . declaration program
    (2) program -> . definition program
    (3) program -> . empty
    (4) declaration -> . DECL ID LPAREN function_args RPAREN COLON return_type
    (5) definition -> . DEF ID LPAREN function_args RPAREN COLON return_type block
    (68) empty -> .

    DECL            shift and go to state 5
    DEF             shift and go to state 6
    $end            reduce using rule 68 (empty -> .)

    definition                     shift and go to state 3
    program                        shift and go to state 8
    declaration                    shift and go to state 2
    empty                          shift and go to state 4

state 4

    (3) program -> empty .

    $end            reduce using rule 3 (program -> empty .)


state 5

    (4) declaration -> DECL . ID LPAREN function_args RPAREN COLON return_type

    ID              shift and go to state 9


state 6

    (5) definition -> DEF . ID LPAREN function_args RPAREN COLON return_type block

    ID              shift and go to state 10


state 7

    (1) program -> declaration program .

    $end            reduce using rule 1 (program -> declaration program .)


state 8

    (2) program -> definition program .

    $end            reduce using rule 2 (program -> definition program .)


state 9

    (4) declaration -> DECL ID . LPAREN function_args RPAREN COLON return_type

    LPAREN          shift and go to state 11


state 10

    (5) definition -> DEF ID . LPAREN function_args RPAREN COLON return_type block

    LPAREN          shift and go to state 12


state 11

    (4) declaration -> DECL ID LPAREN . function_args RPAREN COLON return_type
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (68) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 68 (empty -> .)

    function_args                  shift and go to state 14
    empty                          shift and go to state 16

state 12

    (5) definition -> DEF ID LPAREN . function_args RPAREN COLON return_type block
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (68) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 68 (empty -> .)

    function_args                  shift and go to state 17
    empty                          shift and go to state 16

state 13

    (6) function_args -> ID . COLON var_type function_args

    COLON           shift and go to state 18


state 14

    (4) declaration -> DECL ID LPAREN function_args . RPAREN COLON return_type

    RPAREN          shift and go to state 19


state 15

    (7) function_args -> COMMA . function_args
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (68) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 68 (empty -> .)

    function_args                  shift and go to state 20
    empty                          shift and go to state 16

state 16

    (8) function_args -> empty .

    RPAREN          reduce using rule 8 (function_args -> empty .)


state 17

    (5) definition -> DEF ID LPAREN function_args . RPAREN COLON return_type block

    RPAREN          shift and go to state 21


state 18

    (6) function_args -> ID COLON . var_type function_args
    (32) var_type -> . FLOAT
    (33) var_type -> . INT
    (34) var_type -> . STRING
    (35) var_type -> . BOOLEAN

    FLOAT           shift and go to state 23
    INT             shift and go to state 24
    STRING          shift and go to state 25
    BOOLEAN         shift and go to state 26

    var_type                       shift and go to state 22

state 19

    (4) declaration -> DECL ID LPAREN function_args RPAREN . COLON return_type

    COLON           shift and go to state 27


state 20

    (7) function_args -> COMMA function_args .

    RPAREN          reduce using rule 7 (function_args -> COMMA function_args .)


state 21

    (5) definition -> DEF ID LPAREN function_args RPAREN . COLON return_type block

    COLON           shift and go to state 28


state 22

    (6) function_args -> ID COLON var_type . function_args
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (68) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 68 (empty -> .)

    function_args                  shift and go to state 29
    empty                          shift and go to state 16

state 23

    (32) var_type -> FLOAT .

    ID              reduce using rule 32 (var_type -> FLOAT .)
    COMMA           reduce using rule 32 (var_type -> FLOAT .)
    RPAREN          reduce using rule 32 (var_type -> FLOAT .)
    EQUALS          reduce using rule 32 (var_type -> FLOAT .)


state 24

    (33) var_type -> INT .

    ID              reduce using rule 33 (var_type -> INT .)
    COMMA           reduce using rule 33 (var_type -> INT .)
    RPAREN          reduce using rule 33 (var_type -> INT .)
    EQUALS          reduce using rule 33 (var_type -> INT .)


state 25

    (34) var_type -> STRING .

    ID              reduce using rule 34 (var_type -> STRING .)
    COMMA           reduce using rule 34 (var_type -> STRING .)
    RPAREN          reduce using rule 34 (var_type -> STRING .)
    EQUALS          reduce using rule 34 (var_type -> STRING .)


state 26

    (35) var_type -> BOOLEAN .

    ID              reduce using rule 35 (var_type -> BOOLEAN .)
    COMMA           reduce using rule 35 (var_type -> BOOLEAN .)
    RPAREN          reduce using rule 35 (var_type -> BOOLEAN .)
    EQUALS          reduce using rule 35 (var_type -> BOOLEAN .)


state 27

    (4) declaration -> DECL ID LPAREN function_args RPAREN COLON . return_type
    (9) return_type -> . INT
    (10) return_type -> . FLOAT
    (11) return_type -> . STRING
    (12) return_type -> . BOOLEAN
    (13) return_type -> . VOID

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    BOOLEAN         shift and go to state 34
    VOID            shift and go to state 35

    return_type                    shift and go to state 30

state 28

    (5) definition -> DEF ID LPAREN function_args RPAREN COLON . return_type block
    (9) return_type -> . INT
    (10) return_type -> . FLOAT
    (11) return_type -> . STRING
    (12) return_type -> . BOOLEAN
    (13) return_type -> . VOID

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    BOOLEAN         shift and go to state 34
    VOID            shift and go to state 35

    return_type                    shift and go to state 36

state 29

    (6) function_args -> ID COLON var_type function_args .

    RPAREN          reduce using rule 6 (function_args -> ID COLON var_type function_args .)


state 30

    (4) declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .

    DECL            reduce using rule 4 (declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .)
    DEF             reduce using rule 4 (declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .)
    $end            reduce using rule 4 (declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .)


state 31

    (9) return_type -> INT .

    DECL            reduce using rule 9 (return_type -> INT .)
    DEF             reduce using rule 9 (return_type -> INT .)
    $end            reduce using rule 9 (return_type -> INT .)
    LBRACE          reduce using rule 9 (return_type -> INT .)


state 32

    (10) return_type -> FLOAT .

    DECL            reduce using rule 10 (return_type -> FLOAT .)
    DEF             reduce using rule 10 (return_type -> FLOAT .)
    $end            reduce using rule 10 (return_type -> FLOAT .)
    LBRACE          reduce using rule 10 (return_type -> FLOAT .)


state 33

    (11) return_type -> STRING .

    DECL            reduce using rule 11 (return_type -> STRING .)
    DEF             reduce using rule 11 (return_type -> STRING .)
    $end            reduce using rule 11 (return_type -> STRING .)
    LBRACE          reduce using rule 11 (return_type -> STRING .)


state 34

    (12) return_type -> BOOLEAN .

    DECL            reduce using rule 12 (return_type -> BOOLEAN .)
    DEF             reduce using rule 12 (return_type -> BOOLEAN .)
    $end            reduce using rule 12 (return_type -> BOOLEAN .)
    LBRACE          reduce using rule 12 (return_type -> BOOLEAN .)


state 35

    (13) return_type -> VOID .

    DECL            reduce using rule 13 (return_type -> VOID .)
    DEF             reduce using rule 13 (return_type -> VOID .)
    $end            reduce using rule 13 (return_type -> VOID .)
    LBRACE          reduce using rule 13 (return_type -> VOID .)


state 36

    (5) definition -> DEF ID LPAREN function_args RPAREN COLON return_type . block
    (14) block -> . LBRACE recursive_statement RBRACE

    LBRACE          shift and go to state 38

    block                          shift and go to state 37

state 37

    (5) definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .

    DECL            reduce using rule 5 (definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .)
    DEF             reduce using rule 5 (definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .)
    $end            reduce using rule 5 (definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .)


state 38

    (14) block -> LBRACE . recursive_statement RBRACE
    (15) recursive_statement -> . statement recursive_statement
    (16) recursive_statement -> . empty
    (17) statement -> . return_statement
    (18) statement -> . expression SEMI
    (19) statement -> . if_statement
    (20) statement -> . while_statement
    (21) statement -> . variable_declaration
    (22) statement -> . variable_assignment
    (68) empty -> .
    (23) return_statement -> . RETURN ret_value SEMI
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (26) if_statement -> . IF expression block else_statement
    (29) while_statement -> . WHILE expression block
    (30) variable_declaration -> . ID COLON var_type EQUALS expression SEMI
    (31) variable_assignment -> . ID EQUALS expression SEMI
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    RBRACE          reduce using rule 68 (empty -> .)
    RETURN          shift and go to state 48
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    ID              shift and go to state 57
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    recursive_statement            shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    return_statement               shift and go to state 42
    expression                     shift and go to state 43
    if_statement                   shift and go to state 44
    while_statement                shift and go to state 45
    variable_declaration           shift and go to state 46
    variable_assignment            shift and go to state 47
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 39

    (14) block -> LBRACE recursive_statement . RBRACE

    RBRACE          shift and go to state 63


state 40

    (15) recursive_statement -> statement . recursive_statement
    (15) recursive_statement -> . statement recursive_statement
    (16) recursive_statement -> . empty
    (17) statement -> . return_statement
    (18) statement -> . expression SEMI
    (19) statement -> . if_statement
    (20) statement -> . while_statement
    (21) statement -> . variable_declaration
    (22) statement -> . variable_assignment
    (68) empty -> .
    (23) return_statement -> . RETURN ret_value SEMI
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (26) if_statement -> . IF expression block else_statement
    (29) while_statement -> . WHILE expression block
    (30) variable_declaration -> . ID COLON var_type EQUALS expression SEMI
    (31) variable_assignment -> . ID EQUALS expression SEMI
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    RBRACE          reduce using rule 68 (empty -> .)
    RETURN          shift and go to state 48
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    ID              shift and go to state 57
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    statement                      shift and go to state 40
    recursive_statement            shift and go to state 64
    empty                          shift and go to state 41
    return_statement               shift and go to state 42
    expression                     shift and go to state 43
    if_statement                   shift and go to state 44
    while_statement                shift and go to state 45
    variable_declaration           shift and go to state 46
    variable_assignment            shift and go to state 47
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 41

    (16) recursive_statement -> empty .

    RBRACE          reduce using rule 16 (recursive_statement -> empty .)


state 42

    (17) statement -> return_statement .

    RETURN          reduce using rule 17 (statement -> return_statement .)
    IF              reduce using rule 17 (statement -> return_statement .)
    WHILE           reduce using rule 17 (statement -> return_statement .)
    ID              reduce using rule 17 (statement -> return_statement .)
    NOT             reduce using rule 17 (statement -> return_statement .)
    FLOAT_LITERAL   reduce using rule 17 (statement -> return_statement .)
    INT_LITERAL     reduce using rule 17 (statement -> return_statement .)
    STRING_LITERAL  reduce using rule 17 (statement -> return_statement .)
    BOOLEAN_LITERAL reduce using rule 17 (statement -> return_statement .)
    RBRACE          reduce using rule 17 (statement -> return_statement .)


state 43

    (18) statement -> expression . SEMI
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78


state 44

    (19) statement -> if_statement .

    RETURN          reduce using rule 19 (statement -> if_statement .)
    IF              reduce using rule 19 (statement -> if_statement .)
    WHILE           reduce using rule 19 (statement -> if_statement .)
    ID              reduce using rule 19 (statement -> if_statement .)
    NOT             reduce using rule 19 (statement -> if_statement .)
    FLOAT_LITERAL   reduce using rule 19 (statement -> if_statement .)
    INT_LITERAL     reduce using rule 19 (statement -> if_statement .)
    STRING_LITERAL  reduce using rule 19 (statement -> if_statement .)
    BOOLEAN_LITERAL reduce using rule 19 (statement -> if_statement .)
    RBRACE          reduce using rule 19 (statement -> if_statement .)


state 45

    (20) statement -> while_statement .

    RETURN          reduce using rule 20 (statement -> while_statement .)
    IF              reduce using rule 20 (statement -> while_statement .)
    WHILE           reduce using rule 20 (statement -> while_statement .)
    ID              reduce using rule 20 (statement -> while_statement .)
    NOT             reduce using rule 20 (statement -> while_statement .)
    FLOAT_LITERAL   reduce using rule 20 (statement -> while_statement .)
    INT_LITERAL     reduce using rule 20 (statement -> while_statement .)
    STRING_LITERAL  reduce using rule 20 (statement -> while_statement .)
    BOOLEAN_LITERAL reduce using rule 20 (statement -> while_statement .)
    RBRACE          reduce using rule 20 (statement -> while_statement .)


state 46

    (21) statement -> variable_declaration .

    RETURN          reduce using rule 21 (statement -> variable_declaration .)
    IF              reduce using rule 21 (statement -> variable_declaration .)
    WHILE           reduce using rule 21 (statement -> variable_declaration .)
    ID              reduce using rule 21 (statement -> variable_declaration .)
    NOT             reduce using rule 21 (statement -> variable_declaration .)
    FLOAT_LITERAL   reduce using rule 21 (statement -> variable_declaration .)
    INT_LITERAL     reduce using rule 21 (statement -> variable_declaration .)
    STRING_LITERAL  reduce using rule 21 (statement -> variable_declaration .)
    BOOLEAN_LITERAL reduce using rule 21 (statement -> variable_declaration .)
    RBRACE          reduce using rule 21 (statement -> variable_declaration .)


state 47

    (22) statement -> variable_assignment .

    RETURN          reduce using rule 22 (statement -> variable_assignment .)
    IF              reduce using rule 22 (statement -> variable_assignment .)
    WHILE           reduce using rule 22 (statement -> variable_assignment .)
    ID              reduce using rule 22 (statement -> variable_assignment .)
    NOT             reduce using rule 22 (statement -> variable_assignment .)
    FLOAT_LITERAL   reduce using rule 22 (statement -> variable_assignment .)
    INT_LITERAL     reduce using rule 22 (statement -> variable_assignment .)
    STRING_LITERAL  reduce using rule 22 (statement -> variable_assignment .)
    BOOLEAN_LITERAL reduce using rule 22 (statement -> variable_assignment .)
    RBRACE          reduce using rule 22 (statement -> variable_assignment .)


state 48

    (23) return_statement -> RETURN . ret_value SEMI
    (24) ret_value -> . expression
    (25) ret_value -> . empty
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (68) empty -> .
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    SEMI            reduce using rule 68 (empty -> .)
    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    ret_value                      shift and go to state 79
    expression                     shift and go to state 80
    empty                          shift and go to state 81
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 49

    (36) expression -> expression_binary_operation .

    SEMI            reduce using rule 36 (expression -> expression_binary_operation .)
    PLUS            reduce using rule 36 (expression -> expression_binary_operation .)
    MINUS           reduce using rule 36 (expression -> expression_binary_operation .)
    TIMES           reduce using rule 36 (expression -> expression_binary_operation .)
    DIVIDE          reduce using rule 36 (expression -> expression_binary_operation .)
    MOD             reduce using rule 36 (expression -> expression_binary_operation .)
    AND             reduce using rule 36 (expression -> expression_binary_operation .)
    OR              reduce using rule 36 (expression -> expression_binary_operation .)
    LT              reduce using rule 36 (expression -> expression_binary_operation .)
    GT              reduce using rule 36 (expression -> expression_binary_operation .)
    LE              reduce using rule 36 (expression -> expression_binary_operation .)
    GE              reduce using rule 36 (expression -> expression_binary_operation .)
    EQ              reduce using rule 36 (expression -> expression_binary_operation .)
    NEQ             reduce using rule 36 (expression -> expression_binary_operation .)
    LBRACE          reduce using rule 36 (expression -> expression_binary_operation .)
    COMMA           reduce using rule 36 (expression -> expression_binary_operation .)
    ID              reduce using rule 36 (expression -> expression_binary_operation .)
    NOT             reduce using rule 36 (expression -> expression_binary_operation .)
    FLOAT_LITERAL   reduce using rule 36 (expression -> expression_binary_operation .)
    INT_LITERAL     reduce using rule 36 (expression -> expression_binary_operation .)
    STRING_LITERAL  reduce using rule 36 (expression -> expression_binary_operation .)
    BOOLEAN_LITERAL reduce using rule 36 (expression -> expression_binary_operation .)
    RPAREN          reduce using rule 36 (expression -> expression_binary_operation .)
    RBRACKET        reduce using rule 36 (expression -> expression_binary_operation .)


state 50

    (37) expression -> expression_variable .

    SEMI            reduce using rule 37 (expression -> expression_variable .)
    PLUS            reduce using rule 37 (expression -> expression_variable .)
    MINUS           reduce using rule 37 (expression -> expression_variable .)
    TIMES           reduce using rule 37 (expression -> expression_variable .)
    DIVIDE          reduce using rule 37 (expression -> expression_variable .)
    MOD             reduce using rule 37 (expression -> expression_variable .)
    AND             reduce using rule 37 (expression -> expression_variable .)
    OR              reduce using rule 37 (expression -> expression_variable .)
    LT              reduce using rule 37 (expression -> expression_variable .)
    GT              reduce using rule 37 (expression -> expression_variable .)
    LE              reduce using rule 37 (expression -> expression_variable .)
    GE              reduce using rule 37 (expression -> expression_variable .)
    EQ              reduce using rule 37 (expression -> expression_variable .)
    NEQ             reduce using rule 37 (expression -> expression_variable .)
    LBRACE          reduce using rule 37 (expression -> expression_variable .)
    COMMA           reduce using rule 37 (expression -> expression_variable .)
    ID              reduce using rule 37 (expression -> expression_variable .)
    NOT             reduce using rule 37 (expression -> expression_variable .)
    FLOAT_LITERAL   reduce using rule 37 (expression -> expression_variable .)
    INT_LITERAL     reduce using rule 37 (expression -> expression_variable .)
    STRING_LITERAL  reduce using rule 37 (expression -> expression_variable .)
    BOOLEAN_LITERAL reduce using rule 37 (expression -> expression_variable .)
    RPAREN          reduce using rule 37 (expression -> expression_variable .)
    RBRACKET        reduce using rule 37 (expression -> expression_variable .)


state 51

    (38) expression -> expression_unary_operation .

    SEMI            reduce using rule 38 (expression -> expression_unary_operation .)
    PLUS            reduce using rule 38 (expression -> expression_unary_operation .)
    MINUS           reduce using rule 38 (expression -> expression_unary_operation .)
    TIMES           reduce using rule 38 (expression -> expression_unary_operation .)
    DIVIDE          reduce using rule 38 (expression -> expression_unary_operation .)
    MOD             reduce using rule 38 (expression -> expression_unary_operation .)
    AND             reduce using rule 38 (expression -> expression_unary_operation .)
    OR              reduce using rule 38 (expression -> expression_unary_operation .)
    LT              reduce using rule 38 (expression -> expression_unary_operation .)
    GT              reduce using rule 38 (expression -> expression_unary_operation .)
    LE              reduce using rule 38 (expression -> expression_unary_operation .)
    GE              reduce using rule 38 (expression -> expression_unary_operation .)
    EQ              reduce using rule 38 (expression -> expression_unary_operation .)
    NEQ             reduce using rule 38 (expression -> expression_unary_operation .)
    LBRACE          reduce using rule 38 (expression -> expression_unary_operation .)
    COMMA           reduce using rule 38 (expression -> expression_unary_operation .)
    ID              reduce using rule 38 (expression -> expression_unary_operation .)
    NOT             reduce using rule 38 (expression -> expression_unary_operation .)
    FLOAT_LITERAL   reduce using rule 38 (expression -> expression_unary_operation .)
    INT_LITERAL     reduce using rule 38 (expression -> expression_unary_operation .)
    STRING_LITERAL  reduce using rule 38 (expression -> expression_unary_operation .)
    BOOLEAN_LITERAL reduce using rule 38 (expression -> expression_unary_operation .)
    RPAREN          reduce using rule 38 (expression -> expression_unary_operation .)
    RBRACKET        reduce using rule 38 (expression -> expression_unary_operation .)


state 52

    (39) expression -> expression_literal .

    SEMI            reduce using rule 39 (expression -> expression_literal .)
    PLUS            reduce using rule 39 (expression -> expression_literal .)
    MINUS           reduce using rule 39 (expression -> expression_literal .)
    TIMES           reduce using rule 39 (expression -> expression_literal .)
    DIVIDE          reduce using rule 39 (expression -> expression_literal .)
    MOD             reduce using rule 39 (expression -> expression_literal .)
    AND             reduce using rule 39 (expression -> expression_literal .)
    OR              reduce using rule 39 (expression -> expression_literal .)
    LT              reduce using rule 39 (expression -> expression_literal .)
    GT              reduce using rule 39 (expression -> expression_literal .)
    LE              reduce using rule 39 (expression -> expression_literal .)
    GE              reduce using rule 39 (expression -> expression_literal .)
    EQ              reduce using rule 39 (expression -> expression_literal .)
    NEQ             reduce using rule 39 (expression -> expression_literal .)
    LBRACE          reduce using rule 39 (expression -> expression_literal .)
    COMMA           reduce using rule 39 (expression -> expression_literal .)
    ID              reduce using rule 39 (expression -> expression_literal .)
    NOT             reduce using rule 39 (expression -> expression_literal .)
    FLOAT_LITERAL   reduce using rule 39 (expression -> expression_literal .)
    INT_LITERAL     reduce using rule 39 (expression -> expression_literal .)
    STRING_LITERAL  reduce using rule 39 (expression -> expression_literal .)
    BOOLEAN_LITERAL reduce using rule 39 (expression -> expression_literal .)
    RPAREN          reduce using rule 39 (expression -> expression_literal .)
    RBRACKET        reduce using rule 39 (expression -> expression_literal .)


state 53

    (40) expression -> function_invocation .

    SEMI            reduce using rule 40 (expression -> function_invocation .)
    PLUS            reduce using rule 40 (expression -> function_invocation .)
    MINUS           reduce using rule 40 (expression -> function_invocation .)
    TIMES           reduce using rule 40 (expression -> function_invocation .)
    DIVIDE          reduce using rule 40 (expression -> function_invocation .)
    MOD             reduce using rule 40 (expression -> function_invocation .)
    AND             reduce using rule 40 (expression -> function_invocation .)
    OR              reduce using rule 40 (expression -> function_invocation .)
    LT              reduce using rule 40 (expression -> function_invocation .)
    GT              reduce using rule 40 (expression -> function_invocation .)
    LE              reduce using rule 40 (expression -> function_invocation .)
    GE              reduce using rule 40 (expression -> function_invocation .)
    EQ              reduce using rule 40 (expression -> function_invocation .)
    NEQ             reduce using rule 40 (expression -> function_invocation .)
    LBRACE          reduce using rule 40 (expression -> function_invocation .)
    COMMA           reduce using rule 40 (expression -> function_invocation .)
    ID              reduce using rule 40 (expression -> function_invocation .)
    NOT             reduce using rule 40 (expression -> function_invocation .)
    FLOAT_LITERAL   reduce using rule 40 (expression -> function_invocation .)
    INT_LITERAL     reduce using rule 40 (expression -> function_invocation .)
    STRING_LITERAL  reduce using rule 40 (expression -> function_invocation .)
    BOOLEAN_LITERAL reduce using rule 40 (expression -> function_invocation .)
    RPAREN          reduce using rule 40 (expression -> function_invocation .)
    RBRACKET        reduce using rule 40 (expression -> function_invocation .)


state 54

    (41) expression -> index_access .

    SEMI            reduce using rule 41 (expression -> index_access .)
    PLUS            reduce using rule 41 (expression -> index_access .)
    MINUS           reduce using rule 41 (expression -> index_access .)
    TIMES           reduce using rule 41 (expression -> index_access .)
    DIVIDE          reduce using rule 41 (expression -> index_access .)
    MOD             reduce using rule 41 (expression -> index_access .)
    AND             reduce using rule 41 (expression -> index_access .)
    OR              reduce using rule 41 (expression -> index_access .)
    LT              reduce using rule 41 (expression -> index_access .)
    GT              reduce using rule 41 (expression -> index_access .)
    LE              reduce using rule 41 (expression -> index_access .)
    GE              reduce using rule 41 (expression -> index_access .)
    EQ              reduce using rule 41 (expression -> index_access .)
    NEQ             reduce using rule 41 (expression -> index_access .)
    LBRACE          reduce using rule 41 (expression -> index_access .)
    COMMA           reduce using rule 41 (expression -> index_access .)
    ID              reduce using rule 41 (expression -> index_access .)
    NOT             reduce using rule 41 (expression -> index_access .)
    FLOAT_LITERAL   reduce using rule 41 (expression -> index_access .)
    INT_LITERAL     reduce using rule 41 (expression -> index_access .)
    STRING_LITERAL  reduce using rule 41 (expression -> index_access .)
    BOOLEAN_LITERAL reduce using rule 41 (expression -> index_access .)
    RPAREN          reduce using rule 41 (expression -> index_access .)
    RBRACKET        reduce using rule 41 (expression -> index_access .)


state 55

    (26) if_statement -> IF . expression block else_statement
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 83
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 56

    (29) while_statement -> WHILE . expression block
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 84
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 57

    (30) variable_declaration -> ID . COLON var_type EQUALS expression SEMI
    (31) variable_assignment -> ID . EQUALS expression SEMI
    (55) expression_variable -> ID .
    (61) function_invocation -> ID . LPAREN func_invocation_args RPAREN
    (65) index_access -> ID . index_access_aux
    (66) index_access_aux -> . LBRACKET expression RBRACKET
    (67) index_access_aux -> . LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET

    COLON           shift and go to state 85
    EQUALS          shift and go to state 86
    SEMI            reduce using rule 55 (expression_variable -> ID .)
    PLUS            reduce using rule 55 (expression_variable -> ID .)
    MINUS           reduce using rule 55 (expression_variable -> ID .)
    TIMES           reduce using rule 55 (expression_variable -> ID .)
    DIVIDE          reduce using rule 55 (expression_variable -> ID .)
    MOD             reduce using rule 55 (expression_variable -> ID .)
    AND             reduce using rule 55 (expression_variable -> ID .)
    OR              reduce using rule 55 (expression_variable -> ID .)
    LT              reduce using rule 55 (expression_variable -> ID .)
    GT              reduce using rule 55 (expression_variable -> ID .)
    LE              reduce using rule 55 (expression_variable -> ID .)
    GE              reduce using rule 55 (expression_variable -> ID .)
    EQ              reduce using rule 55 (expression_variable -> ID .)
    NEQ             reduce using rule 55 (expression_variable -> ID .)
    LPAREN          shift and go to state 87
    LBRACKET        shift and go to state 89

    index_access_aux               shift and go to state 88

state 58

    (56) expression_unary_operation -> NOT . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 90
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 59

    (57) expression_literal -> FLOAT_LITERAL .

    SEMI            reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    PLUS            reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    MINUS           reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    TIMES           reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    MOD             reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    AND             reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    OR              reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    LT              reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    GT              reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    LE              reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    GE              reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    EQ              reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    NEQ             reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    LBRACE          reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    COMMA           reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    ID              reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    NOT             reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    FLOAT_LITERAL   reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    INT_LITERAL     reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    STRING_LITERAL  reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)
    RBRACKET        reduce using rule 57 (expression_literal -> FLOAT_LITERAL .)


state 60

    (58) expression_literal -> INT_LITERAL .

    SEMI            reduce using rule 58 (expression_literal -> INT_LITERAL .)
    PLUS            reduce using rule 58 (expression_literal -> INT_LITERAL .)
    MINUS           reduce using rule 58 (expression_literal -> INT_LITERAL .)
    TIMES           reduce using rule 58 (expression_literal -> INT_LITERAL .)
    DIVIDE          reduce using rule 58 (expression_literal -> INT_LITERAL .)
    MOD             reduce using rule 58 (expression_literal -> INT_LITERAL .)
    AND             reduce using rule 58 (expression_literal -> INT_LITERAL .)
    OR              reduce using rule 58 (expression_literal -> INT_LITERAL .)
    LT              reduce using rule 58 (expression_literal -> INT_LITERAL .)
    GT              reduce using rule 58 (expression_literal -> INT_LITERAL .)
    LE              reduce using rule 58 (expression_literal -> INT_LITERAL .)
    GE              reduce using rule 58 (expression_literal -> INT_LITERAL .)
    EQ              reduce using rule 58 (expression_literal -> INT_LITERAL .)
    NEQ             reduce using rule 58 (expression_literal -> INT_LITERAL .)
    LBRACE          reduce using rule 58 (expression_literal -> INT_LITERAL .)
    COMMA           reduce using rule 58 (expression_literal -> INT_LITERAL .)
    ID              reduce using rule 58 (expression_literal -> INT_LITERAL .)
    NOT             reduce using rule 58 (expression_literal -> INT_LITERAL .)
    FLOAT_LITERAL   reduce using rule 58 (expression_literal -> INT_LITERAL .)
    INT_LITERAL     reduce using rule 58 (expression_literal -> INT_LITERAL .)
    STRING_LITERAL  reduce using rule 58 (expression_literal -> INT_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 58 (expression_literal -> INT_LITERAL .)
    RPAREN          reduce using rule 58 (expression_literal -> INT_LITERAL .)
    RBRACKET        reduce using rule 58 (expression_literal -> INT_LITERAL .)


state 61

    (59) expression_literal -> STRING_LITERAL .

    SEMI            reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    PLUS            reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    MINUS           reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    TIMES           reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    MOD             reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    AND             reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    OR              reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    LT              reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    GT              reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    LE              reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    GE              reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    EQ              reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    NEQ             reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    LBRACE          reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    COMMA           reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    ID              reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    NOT             reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    FLOAT_LITERAL   reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    INT_LITERAL     reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 59 (expression_literal -> STRING_LITERAL .)
    RBRACKET        reduce using rule 59 (expression_literal -> STRING_LITERAL .)


state 62

    (60) expression_literal -> BOOLEAN_LITERAL .

    SEMI            reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    PLUS            reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    MINUS           reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    TIMES           reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    DIVIDE          reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    MOD             reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    AND             reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    OR              reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    LT              reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    GT              reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    LE              reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    GE              reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    EQ              reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    NEQ             reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    LBRACE          reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    COMMA           reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    ID              reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    NOT             reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    FLOAT_LITERAL   reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    INT_LITERAL     reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    STRING_LITERAL  reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    RPAREN          reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)
    RBRACKET        reduce using rule 60 (expression_literal -> BOOLEAN_LITERAL .)


state 63

    (14) block -> LBRACE recursive_statement RBRACE .

    DECL            reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    DEF             reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    $end            reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    ELSE            reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    RETURN          reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    IF              reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    WHILE           reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    ID              reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    NOT             reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    FLOAT_LITERAL   reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    INT_LITERAL     reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    STRING_LITERAL  reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    BOOLEAN_LITERAL reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)
    RBRACE          reduce using rule 14 (block -> LBRACE recursive_statement RBRACE .)


state 64

    (15) recursive_statement -> statement recursive_statement .

    RBRACE          reduce using rule 15 (recursive_statement -> statement recursive_statement .)


state 65

    (18) statement -> expression SEMI .

    RETURN          reduce using rule 18 (statement -> expression SEMI .)
    IF              reduce using rule 18 (statement -> expression SEMI .)
    WHILE           reduce using rule 18 (statement -> expression SEMI .)
    ID              reduce using rule 18 (statement -> expression SEMI .)
    NOT             reduce using rule 18 (statement -> expression SEMI .)
    FLOAT_LITERAL   reduce using rule 18 (statement -> expression SEMI .)
    INT_LITERAL     reduce using rule 18 (statement -> expression SEMI .)
    STRING_LITERAL  reduce using rule 18 (statement -> expression SEMI .)
    BOOLEAN_LITERAL reduce using rule 18 (statement -> expression SEMI .)
    RBRACE          reduce using rule 18 (statement -> expression SEMI .)


state 66

    (42) expression_binary_operation -> expression PLUS . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 91
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 67

    (43) expression_binary_operation -> expression MINUS . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 92
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 68

    (44) expression_binary_operation -> expression TIMES . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 93
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 69

    (45) expression_binary_operation -> expression DIVIDE . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 94
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 70

    (46) expression_binary_operation -> expression MOD . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 95
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 71

    (47) expression_binary_operation -> expression AND . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 96
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 72

    (48) expression_binary_operation -> expression OR . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 97
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 73

    (49) expression_binary_operation -> expression LT . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 98
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 74

    (50) expression_binary_operation -> expression GT . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 99
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 75

    (51) expression_binary_operation -> expression LE . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 100
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 76

    (52) expression_binary_operation -> expression GE . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 101
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 77

    (53) expression_binary_operation -> expression EQ . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 102
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 78

    (54) expression_binary_operation -> expression NEQ . expression
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 103
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 79

    (23) return_statement -> RETURN ret_value . SEMI

    SEMI            shift and go to state 104


state 80

    (24) ret_value -> expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 24 (ret_value -> expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78


state 81

    (25) ret_value -> empty .

    SEMI            reduce using rule 25 (ret_value -> empty .)


state 82

    (55) expression_variable -> ID .
    (61) function_invocation -> ID . LPAREN func_invocation_args RPAREN
    (65) index_access -> ID . index_access_aux
    (66) index_access_aux -> . LBRACKET expression RBRACKET
    (67) index_access_aux -> . LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET

    PLUS            reduce using rule 55 (expression_variable -> ID .)
    MINUS           reduce using rule 55 (expression_variable -> ID .)
    TIMES           reduce using rule 55 (expression_variable -> ID .)
    DIVIDE          reduce using rule 55 (expression_variable -> ID .)
    MOD             reduce using rule 55 (expression_variable -> ID .)
    AND             reduce using rule 55 (expression_variable -> ID .)
    OR              reduce using rule 55 (expression_variable -> ID .)
    LT              reduce using rule 55 (expression_variable -> ID .)
    GT              reduce using rule 55 (expression_variable -> ID .)
    LE              reduce using rule 55 (expression_variable -> ID .)
    GE              reduce using rule 55 (expression_variable -> ID .)
    EQ              reduce using rule 55 (expression_variable -> ID .)
    NEQ             reduce using rule 55 (expression_variable -> ID .)
    SEMI            reduce using rule 55 (expression_variable -> ID .)
    LBRACE          reduce using rule 55 (expression_variable -> ID .)
    COMMA           reduce using rule 55 (expression_variable -> ID .)
    ID              reduce using rule 55 (expression_variable -> ID .)
    NOT             reduce using rule 55 (expression_variable -> ID .)
    FLOAT_LITERAL   reduce using rule 55 (expression_variable -> ID .)
    INT_LITERAL     reduce using rule 55 (expression_variable -> ID .)
    STRING_LITERAL  reduce using rule 55 (expression_variable -> ID .)
    BOOLEAN_LITERAL reduce using rule 55 (expression_variable -> ID .)
    RPAREN          reduce using rule 55 (expression_variable -> ID .)
    RBRACKET        reduce using rule 55 (expression_variable -> ID .)
    LPAREN          shift and go to state 87
    LBRACKET        shift and go to state 89

    index_access_aux               shift and go to state 88

state 83

    (26) if_statement -> IF expression . block else_statement
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression
    (14) block -> . LBRACE recursive_statement RBRACE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78
    LBRACE          shift and go to state 38

    block                          shift and go to state 105

state 84

    (29) while_statement -> WHILE expression . block
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression
    (14) block -> . LBRACE recursive_statement RBRACE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78
    LBRACE          shift and go to state 38

    block                          shift and go to state 106

state 85

    (30) variable_declaration -> ID COLON . var_type EQUALS expression SEMI
    (32) var_type -> . FLOAT
    (33) var_type -> . INT
    (34) var_type -> . STRING
    (35) var_type -> . BOOLEAN

    FLOAT           shift and go to state 23
    INT             shift and go to state 24
    STRING          shift and go to state 25
    BOOLEAN         shift and go to state 26

    var_type                       shift and go to state 107

state 86

    (31) variable_assignment -> ID EQUALS . expression SEMI
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 108
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 87

    (61) function_invocation -> ID LPAREN . func_invocation_args RPAREN
    (67) index_access_aux -> LPAREN . func_invocation_args RPAREN LBRACKET expression RBRACKET
    (62) func_invocation_args -> . expression func_invocation_args
    (63) func_invocation_args -> . COMMA func_invocation_args
    (64) func_invocation_args -> . empty
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (68) empty -> .
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    COMMA           shift and go to state 111
    RPAREN          reduce using rule 68 (empty -> .)
    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    func_invocation_args           shift and go to state 109
    expression                     shift and go to state 110
    empty                          shift and go to state 112
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 88

    (65) index_access -> ID index_access_aux .

    SEMI            reduce using rule 65 (index_access -> ID index_access_aux .)
    PLUS            reduce using rule 65 (index_access -> ID index_access_aux .)
    MINUS           reduce using rule 65 (index_access -> ID index_access_aux .)
    TIMES           reduce using rule 65 (index_access -> ID index_access_aux .)
    DIVIDE          reduce using rule 65 (index_access -> ID index_access_aux .)
    MOD             reduce using rule 65 (index_access -> ID index_access_aux .)
    AND             reduce using rule 65 (index_access -> ID index_access_aux .)
    OR              reduce using rule 65 (index_access -> ID index_access_aux .)
    LT              reduce using rule 65 (index_access -> ID index_access_aux .)
    GT              reduce using rule 65 (index_access -> ID index_access_aux .)
    LE              reduce using rule 65 (index_access -> ID index_access_aux .)
    GE              reduce using rule 65 (index_access -> ID index_access_aux .)
    EQ              reduce using rule 65 (index_access -> ID index_access_aux .)
    NEQ             reduce using rule 65 (index_access -> ID index_access_aux .)
    LBRACE          reduce using rule 65 (index_access -> ID index_access_aux .)
    COMMA           reduce using rule 65 (index_access -> ID index_access_aux .)
    ID              reduce using rule 65 (index_access -> ID index_access_aux .)
    NOT             reduce using rule 65 (index_access -> ID index_access_aux .)
    FLOAT_LITERAL   reduce using rule 65 (index_access -> ID index_access_aux .)
    INT_LITERAL     reduce using rule 65 (index_access -> ID index_access_aux .)
    STRING_LITERAL  reduce using rule 65 (index_access -> ID index_access_aux .)
    BOOLEAN_LITERAL reduce using rule 65 (index_access -> ID index_access_aux .)
    RPAREN          reduce using rule 65 (index_access -> ID index_access_aux .)
    RBRACKET        reduce using rule 65 (index_access -> ID index_access_aux .)


state 89

    (66) index_access_aux -> LBRACKET . expression RBRACKET
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 113
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 90

    (56) expression_unary_operation -> NOT expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 56 (expression_unary_operation -> NOT expression .)
    PLUS            reduce using rule 56 (expression_unary_operation -> NOT expression .)
    MINUS           reduce using rule 56 (expression_unary_operation -> NOT expression .)
    TIMES           reduce using rule 56 (expression_unary_operation -> NOT expression .)
    DIVIDE          reduce using rule 56 (expression_unary_operation -> NOT expression .)
    MOD             reduce using rule 56 (expression_unary_operation -> NOT expression .)
    AND             reduce using rule 56 (expression_unary_operation -> NOT expression .)
    OR              reduce using rule 56 (expression_unary_operation -> NOT expression .)
    LT              reduce using rule 56 (expression_unary_operation -> NOT expression .)
    GT              reduce using rule 56 (expression_unary_operation -> NOT expression .)
    LE              reduce using rule 56 (expression_unary_operation -> NOT expression .)
    GE              reduce using rule 56 (expression_unary_operation -> NOT expression .)
    EQ              reduce using rule 56 (expression_unary_operation -> NOT expression .)
    NEQ             reduce using rule 56 (expression_unary_operation -> NOT expression .)
    LBRACE          reduce using rule 56 (expression_unary_operation -> NOT expression .)
    COMMA           reduce using rule 56 (expression_unary_operation -> NOT expression .)
    ID              reduce using rule 56 (expression_unary_operation -> NOT expression .)
    NOT             reduce using rule 56 (expression_unary_operation -> NOT expression .)
    FLOAT_LITERAL   reduce using rule 56 (expression_unary_operation -> NOT expression .)
    INT_LITERAL     reduce using rule 56 (expression_unary_operation -> NOT expression .)
    STRING_LITERAL  reduce using rule 56 (expression_unary_operation -> NOT expression .)
    BOOLEAN_LITERAL reduce using rule 56 (expression_unary_operation -> NOT expression .)
    RPAREN          reduce using rule 56 (expression_unary_operation -> NOT expression .)
    RBRACKET        reduce using rule 56 (expression_unary_operation -> NOT expression .)

  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 91

    (42) expression_binary_operation -> expression PLUS expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    PLUS            reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    MINUS           reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    AND             reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    OR              reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    LT              reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    GT              reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    LE              reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    GE              reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    EQ              reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    NEQ             reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    LBRACE          reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    COMMA           reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    ID              reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    NOT             reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    FLOAT_LITERAL   reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    INT_LITERAL     reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    STRING_LITERAL  reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    BOOLEAN_LITERAL reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    RPAREN          reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    RBRACKET        reduce using rule 42 (expression_binary_operation -> expression PLUS expression .)
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! TIMES           [ reduce using rule 42 (expression_binary_operation -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression_binary_operation -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 42 (expression_binary_operation -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 92

    (43) expression_binary_operation -> expression MINUS expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    PLUS            reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    MINUS           reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    AND             reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    OR              reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    LT              reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    GT              reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    LE              reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    GE              reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    EQ              reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    NEQ             reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    LBRACE          reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    COMMA           reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    ID              reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    NOT             reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    FLOAT_LITERAL   reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    INT_LITERAL     reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    STRING_LITERAL  reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    BOOLEAN_LITERAL reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    RPAREN          reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    RBRACKET        reduce using rule 43 (expression_binary_operation -> expression MINUS expression .)
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! TIMES           [ reduce using rule 43 (expression_binary_operation -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression_binary_operation -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 43 (expression_binary_operation -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 93

    (44) expression_binary_operation -> expression TIMES expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    PLUS            reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    MINUS           reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    TIMES           reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    DIVIDE          reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    MOD             reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    AND             reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    OR              reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    LT              reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    GT              reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    LE              reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    GE              reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    EQ              reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    NEQ             reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    LBRACE          reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    COMMA           reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    ID              reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    NOT             reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    FLOAT_LITERAL   reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    INT_LITERAL     reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    STRING_LITERAL  reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    BOOLEAN_LITERAL reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    RPAREN          reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)
    RBRACKET        reduce using rule 44 (expression_binary_operation -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 94

    (45) expression_binary_operation -> expression DIVIDE expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    PLUS            reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    MINUS           reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    TIMES           reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    MOD             reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    AND             reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    OR              reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    LT              reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    GT              reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    LE              reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    GE              reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    EQ              reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    NEQ             reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    LBRACE          reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    COMMA           reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    ID              reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    NOT             reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    FLOAT_LITERAL   reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    INT_LITERAL     reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    STRING_LITERAL  reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    BOOLEAN_LITERAL reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    RPAREN          reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 45 (expression_binary_operation -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 95

    (46) expression_binary_operation -> expression MOD expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    PLUS            reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    MINUS           reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    TIMES           reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    DIVIDE          reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    MOD             reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    AND             reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    OR              reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    LT              reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    GT              reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    LE              reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    GE              reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    EQ              reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    NEQ             reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    LBRACE          reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    COMMA           reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    ID              reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    NOT             reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    FLOAT_LITERAL   reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    INT_LITERAL     reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    STRING_LITERAL  reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    BOOLEAN_LITERAL reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    RPAREN          reduce using rule 46 (expression_binary_operation -> expression MOD expression .)
    RBRACKET        reduce using rule 46 (expression_binary_operation -> expression MOD expression .)

  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 96

    (47) expression_binary_operation -> expression AND expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    AND             reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    OR              reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    LT              reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    GT              reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    LE              reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    GE              reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    EQ              reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    NEQ             reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    LBRACE          reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    COMMA           reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    ID              reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    NOT             reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    FLOAT_LITERAL   reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    INT_LITERAL     reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    STRING_LITERAL  reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    BOOLEAN_LITERAL reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    RPAREN          reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    RBRACKET        reduce using rule 47 (expression_binary_operation -> expression AND expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 47 (expression_binary_operation -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 47 (expression_binary_operation -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 47 (expression_binary_operation -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 47 (expression_binary_operation -> expression AND expression .) ]
  ! MOD             [ reduce using rule 47 (expression_binary_operation -> expression AND expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 97

    (48) expression_binary_operation -> expression OR expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    AND             reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    OR              reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    LT              reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    GT              reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    LE              reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    GE              reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    EQ              reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    NEQ             reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    LBRACE          reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    COMMA           reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    ID              reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    NOT             reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    FLOAT_LITERAL   reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    INT_LITERAL     reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    STRING_LITERAL  reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    BOOLEAN_LITERAL reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    RPAREN          reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    RBRACKET        reduce using rule 48 (expression_binary_operation -> expression OR expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 48 (expression_binary_operation -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 48 (expression_binary_operation -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 48 (expression_binary_operation -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 48 (expression_binary_operation -> expression OR expression .) ]
  ! MOD             [ reduce using rule 48 (expression_binary_operation -> expression OR expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 98

    (49) expression_binary_operation -> expression LT expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    AND             reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    OR              reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    LT              reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    GT              reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    LE              reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    GE              reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    EQ              reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    NEQ             reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    LBRACE          reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    COMMA           reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    ID              reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    NOT             reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    FLOAT_LITERAL   reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    INT_LITERAL     reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    STRING_LITERAL  reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    BOOLEAN_LITERAL reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    RPAREN          reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    RBRACKET        reduce using rule 49 (expression_binary_operation -> expression LT expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 49 (expression_binary_operation -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 49 (expression_binary_operation -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 49 (expression_binary_operation -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression_binary_operation -> expression LT expression .) ]
  ! MOD             [ reduce using rule 49 (expression_binary_operation -> expression LT expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 99

    (50) expression_binary_operation -> expression GT expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    AND             reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    OR              reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    LT              reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    GT              reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    LE              reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    GE              reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    EQ              reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    NEQ             reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    LBRACE          reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    COMMA           reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    ID              reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    NOT             reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    FLOAT_LITERAL   reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    INT_LITERAL     reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    STRING_LITERAL  reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    BOOLEAN_LITERAL reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    RPAREN          reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    RBRACKET        reduce using rule 50 (expression_binary_operation -> expression GT expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 50 (expression_binary_operation -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 50 (expression_binary_operation -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 50 (expression_binary_operation -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 50 (expression_binary_operation -> expression GT expression .) ]
  ! MOD             [ reduce using rule 50 (expression_binary_operation -> expression GT expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 100

    (51) expression_binary_operation -> expression LE expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    AND             reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    OR              reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    LT              reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    GT              reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    LE              reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    GE              reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    EQ              reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    NEQ             reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    LBRACE          reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    COMMA           reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    ID              reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    NOT             reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    FLOAT_LITERAL   reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    INT_LITERAL     reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    STRING_LITERAL  reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    BOOLEAN_LITERAL reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    RPAREN          reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    RBRACKET        reduce using rule 51 (expression_binary_operation -> expression LE expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 51 (expression_binary_operation -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 51 (expression_binary_operation -> expression LE expression .) ]
  ! TIMES           [ reduce using rule 51 (expression_binary_operation -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 51 (expression_binary_operation -> expression LE expression .) ]
  ! MOD             [ reduce using rule 51 (expression_binary_operation -> expression LE expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 101

    (52) expression_binary_operation -> expression GE expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    AND             reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    OR              reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    LT              reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    GT              reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    LE              reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    GE              reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    EQ              reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    NEQ             reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    LBRACE          reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    COMMA           reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    ID              reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    NOT             reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    FLOAT_LITERAL   reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    INT_LITERAL     reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    STRING_LITERAL  reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    BOOLEAN_LITERAL reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    RPAREN          reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    RBRACKET        reduce using rule 52 (expression_binary_operation -> expression GE expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 52 (expression_binary_operation -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 52 (expression_binary_operation -> expression GE expression .) ]
  ! TIMES           [ reduce using rule 52 (expression_binary_operation -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 52 (expression_binary_operation -> expression GE expression .) ]
  ! MOD             [ reduce using rule 52 (expression_binary_operation -> expression GE expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 102

    (53) expression_binary_operation -> expression EQ expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    AND             reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    OR              reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    LT              reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    GT              reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    LE              reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    GE              reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    EQ              reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    NEQ             reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    LBRACE          reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    COMMA           reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    ID              reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    NOT             reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    FLOAT_LITERAL   reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    INT_LITERAL     reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    STRING_LITERAL  reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    BOOLEAN_LITERAL reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    RPAREN          reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    RBRACKET        reduce using rule 53 (expression_binary_operation -> expression EQ expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 53 (expression_binary_operation -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 53 (expression_binary_operation -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 53 (expression_binary_operation -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 53 (expression_binary_operation -> expression EQ expression .) ]
  ! MOD             [ reduce using rule 53 (expression_binary_operation -> expression EQ expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 103

    (54) expression_binary_operation -> expression NEQ expression .
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    AND             reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    OR              reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    LT              reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    GT              reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    LE              reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    GE              reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    EQ              reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    NEQ             reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    LBRACE          reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    COMMA           reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    ID              reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    NOT             reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    FLOAT_LITERAL   reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    INT_LITERAL     reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    STRING_LITERAL  reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    BOOLEAN_LITERAL reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    RPAREN          reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    RBRACKET        reduce using rule 54 (expression_binary_operation -> expression NEQ expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 54 (expression_binary_operation -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 54 (expression_binary_operation -> expression NEQ expression .) ]
  ! TIMES           [ reduce using rule 54 (expression_binary_operation -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression_binary_operation -> expression NEQ expression .) ]
  ! MOD             [ reduce using rule 54 (expression_binary_operation -> expression NEQ expression .) ]
  ! AND             [ shift and go to state 71 ]
  ! OR              [ shift and go to state 72 ]
  ! LT              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 77 ]
  ! NEQ             [ shift and go to state 78 ]


state 104

    (23) return_statement -> RETURN ret_value SEMI .

    RETURN          reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    IF              reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    WHILE           reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    ID              reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    NOT             reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    FLOAT_LITERAL   reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    INT_LITERAL     reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    STRING_LITERAL  reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    BOOLEAN_LITERAL reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)
    RBRACE          reduce using rule 23 (return_statement -> RETURN ret_value SEMI .)


state 105

    (26) if_statement -> IF expression block . else_statement
    (27) else_statement -> . ELSE block
    (28) else_statement -> . empty
    (68) empty -> .

    ELSE            shift and go to state 115
    RETURN          reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    ID              reduce using rule 68 (empty -> .)
    NOT             reduce using rule 68 (empty -> .)
    FLOAT_LITERAL   reduce using rule 68 (empty -> .)
    INT_LITERAL     reduce using rule 68 (empty -> .)
    STRING_LITERAL  reduce using rule 68 (empty -> .)
    BOOLEAN_LITERAL reduce using rule 68 (empty -> .)
    RBRACE          reduce using rule 68 (empty -> .)

    else_statement                 shift and go to state 114
    empty                          shift and go to state 116

state 106

    (29) while_statement -> WHILE expression block .

    RETURN          reduce using rule 29 (while_statement -> WHILE expression block .)
    IF              reduce using rule 29 (while_statement -> WHILE expression block .)
    WHILE           reduce using rule 29 (while_statement -> WHILE expression block .)
    ID              reduce using rule 29 (while_statement -> WHILE expression block .)
    NOT             reduce using rule 29 (while_statement -> WHILE expression block .)
    FLOAT_LITERAL   reduce using rule 29 (while_statement -> WHILE expression block .)
    INT_LITERAL     reduce using rule 29 (while_statement -> WHILE expression block .)
    STRING_LITERAL  reduce using rule 29 (while_statement -> WHILE expression block .)
    BOOLEAN_LITERAL reduce using rule 29 (while_statement -> WHILE expression block .)
    RBRACE          reduce using rule 29 (while_statement -> WHILE expression block .)


state 107

    (30) variable_declaration -> ID COLON var_type . EQUALS expression SEMI

    EQUALS          shift and go to state 117


state 108

    (31) variable_assignment -> ID EQUALS expression . SEMI
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            shift and go to state 118
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78


state 109

    (61) function_invocation -> ID LPAREN func_invocation_args . RPAREN
    (67) index_access_aux -> LPAREN func_invocation_args . RPAREN LBRACKET expression RBRACKET

    RPAREN          shift and go to state 119


state 110

    (62) func_invocation_args -> expression . func_invocation_args
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression
    (62) func_invocation_args -> . expression func_invocation_args
    (63) func_invocation_args -> . COMMA func_invocation_args
    (64) func_invocation_args -> . empty
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (68) empty -> .
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78
    COMMA           shift and go to state 111
    RPAREN          reduce using rule 68 (empty -> .)
    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 110
    func_invocation_args           shift and go to state 120
    empty                          shift and go to state 112
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 111

    (63) func_invocation_args -> COMMA . func_invocation_args
    (62) func_invocation_args -> . expression func_invocation_args
    (63) func_invocation_args -> . COMMA func_invocation_args
    (64) func_invocation_args -> . empty
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (68) empty -> .
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    COMMA           shift and go to state 111
    RPAREN          reduce using rule 68 (empty -> .)
    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    func_invocation_args           shift and go to state 121
    expression                     shift and go to state 110
    empty                          shift and go to state 112
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 112

    (64) func_invocation_args -> empty .

    RPAREN          reduce using rule 64 (func_invocation_args -> empty .)


state 113

    (66) index_access_aux -> LBRACKET expression . RBRACKET
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    RBRACKET        shift and go to state 122
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78


state 114

    (26) if_statement -> IF expression block else_statement .

    RETURN          reduce using rule 26 (if_statement -> IF expression block else_statement .)
    IF              reduce using rule 26 (if_statement -> IF expression block else_statement .)
    WHILE           reduce using rule 26 (if_statement -> IF expression block else_statement .)
    ID              reduce using rule 26 (if_statement -> IF expression block else_statement .)
    NOT             reduce using rule 26 (if_statement -> IF expression block else_statement .)
    FLOAT_LITERAL   reduce using rule 26 (if_statement -> IF expression block else_statement .)
    INT_LITERAL     reduce using rule 26 (if_statement -> IF expression block else_statement .)
    STRING_LITERAL  reduce using rule 26 (if_statement -> IF expression block else_statement .)
    BOOLEAN_LITERAL reduce using rule 26 (if_statement -> IF expression block else_statement .)
    RBRACE          reduce using rule 26 (if_statement -> IF expression block else_statement .)


state 115

    (27) else_statement -> ELSE . block
    (14) block -> . LBRACE recursive_statement RBRACE

    LBRACE          shift and go to state 38

    block                          shift and go to state 123

state 116

    (28) else_statement -> empty .

    RETURN          reduce using rule 28 (else_statement -> empty .)
    IF              reduce using rule 28 (else_statement -> empty .)
    WHILE           reduce using rule 28 (else_statement -> empty .)
    ID              reduce using rule 28 (else_statement -> empty .)
    NOT             reduce using rule 28 (else_statement -> empty .)
    FLOAT_LITERAL   reduce using rule 28 (else_statement -> empty .)
    INT_LITERAL     reduce using rule 28 (else_statement -> empty .)
    STRING_LITERAL  reduce using rule 28 (else_statement -> empty .)
    BOOLEAN_LITERAL reduce using rule 28 (else_statement -> empty .)
    RBRACE          reduce using rule 28 (else_statement -> empty .)


state 117

    (30) variable_declaration -> ID COLON var_type EQUALS . expression SEMI
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 124
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 118

    (31) variable_assignment -> ID EQUALS expression SEMI .

    RETURN          reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    IF              reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    WHILE           reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    ID              reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    NOT             reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    FLOAT_LITERAL   reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    INT_LITERAL     reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    STRING_LITERAL  reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    BOOLEAN_LITERAL reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)
    RBRACE          reduce using rule 31 (variable_assignment -> ID EQUALS expression SEMI .)


state 119

    (61) function_invocation -> ID LPAREN func_invocation_args RPAREN .
    (67) index_access_aux -> LPAREN func_invocation_args RPAREN . LBRACKET expression RBRACKET

    SEMI            reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    PLUS            reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    MINUS           reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    TIMES           reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    DIVIDE          reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    MOD             reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    AND             reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    OR              reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LT              reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    GT              reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LE              reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    GE              reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    EQ              reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    NEQ             reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LBRACE          reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    COMMA           reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    ID              reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    NOT             reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    FLOAT_LITERAL   reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    INT_LITERAL     reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    STRING_LITERAL  reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    BOOLEAN_LITERAL reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    RPAREN          reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    RBRACKET        reduce using rule 61 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LBRACKET        shift and go to state 125


state 120

    (62) func_invocation_args -> expression func_invocation_args .

    RPAREN          reduce using rule 62 (func_invocation_args -> expression func_invocation_args .)


state 121

    (63) func_invocation_args -> COMMA func_invocation_args .

    RPAREN          reduce using rule 63 (func_invocation_args -> COMMA func_invocation_args .)


state 122

    (66) index_access_aux -> LBRACKET expression RBRACKET .

    SEMI            reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    MOD             reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    AND             reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    OR              reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    LT              reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    GT              reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    LE              reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    GE              reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    EQ              reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    ID              reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    NOT             reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    FLOAT_LITERAL   reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    INT_LITERAL     reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    STRING_LITERAL  reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    BOOLEAN_LITERAL reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 66 (index_access_aux -> LBRACKET expression RBRACKET .)


state 123

    (27) else_statement -> ELSE block .

    RETURN          reduce using rule 27 (else_statement -> ELSE block .)
    IF              reduce using rule 27 (else_statement -> ELSE block .)
    WHILE           reduce using rule 27 (else_statement -> ELSE block .)
    ID              reduce using rule 27 (else_statement -> ELSE block .)
    NOT             reduce using rule 27 (else_statement -> ELSE block .)
    FLOAT_LITERAL   reduce using rule 27 (else_statement -> ELSE block .)
    INT_LITERAL     reduce using rule 27 (else_statement -> ELSE block .)
    STRING_LITERAL  reduce using rule 27 (else_statement -> ELSE block .)
    BOOLEAN_LITERAL reduce using rule 27 (else_statement -> ELSE block .)
    RBRACE          reduce using rule 27 (else_statement -> ELSE block .)


state 124

    (30) variable_declaration -> ID COLON var_type EQUALS expression . SEMI
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    SEMI            shift and go to state 126
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78


state 125

    (67) index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET . expression RBRACKET
    (36) expression -> . expression_binary_operation
    (37) expression -> . expression_variable
    (38) expression -> . expression_unary_operation
    (39) expression -> . expression_literal
    (40) expression -> . function_invocation
    (41) expression -> . index_access
    (42) expression_binary_operation -> . expression PLUS expression
    (43) expression_binary_operation -> . expression MINUS expression
    (44) expression_binary_operation -> . expression TIMES expression
    (45) expression_binary_operation -> . expression DIVIDE expression
    (46) expression_binary_operation -> . expression MOD expression
    (47) expression_binary_operation -> . expression AND expression
    (48) expression_binary_operation -> . expression OR expression
    (49) expression_binary_operation -> . expression LT expression
    (50) expression_binary_operation -> . expression GT expression
    (51) expression_binary_operation -> . expression LE expression
    (52) expression_binary_operation -> . expression GE expression
    (53) expression_binary_operation -> . expression EQ expression
    (54) expression_binary_operation -> . expression NEQ expression
    (55) expression_variable -> . ID
    (56) expression_unary_operation -> . NOT expression
    (57) expression_literal -> . FLOAT_LITERAL
    (58) expression_literal -> . INT_LITERAL
    (59) expression_literal -> . STRING_LITERAL
    (60) expression_literal -> . BOOLEAN_LITERAL
    (61) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (65) index_access -> . ID index_access_aux

    ID              shift and go to state 82
    NOT             shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    INT_LITERAL     shift and go to state 60
    STRING_LITERAL  shift and go to state 61
    BOOLEAN_LITERAL shift and go to state 62

    expression                     shift and go to state 127
    expression_binary_operation    shift and go to state 49
    expression_variable            shift and go to state 50
    expression_unary_operation     shift and go to state 51
    expression_literal             shift and go to state 52
    function_invocation            shift and go to state 53
    index_access                   shift and go to state 54

state 126

    (30) variable_declaration -> ID COLON var_type EQUALS expression SEMI .

    RETURN          reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    IF              reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    WHILE           reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    ID              reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    NOT             reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    FLOAT_LITERAL   reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    INT_LITERAL     reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    STRING_LITERAL  reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    BOOLEAN_LITERAL reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    RBRACE          reduce using rule 30 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)


state 127

    (67) index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression . RBRACKET
    (42) expression_binary_operation -> expression . PLUS expression
    (43) expression_binary_operation -> expression . MINUS expression
    (44) expression_binary_operation -> expression . TIMES expression
    (45) expression_binary_operation -> expression . DIVIDE expression
    (46) expression_binary_operation -> expression . MOD expression
    (47) expression_binary_operation -> expression . AND expression
    (48) expression_binary_operation -> expression . OR expression
    (49) expression_binary_operation -> expression . LT expression
    (50) expression_binary_operation -> expression . GT expression
    (51) expression_binary_operation -> expression . LE expression
    (52) expression_binary_operation -> expression . GE expression
    (53) expression_binary_operation -> expression . EQ expression
    (54) expression_binary_operation -> expression . NEQ expression

    RBRACKET        shift and go to state 128
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    AND             shift and go to state 71
    OR              shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76
    EQ              shift and go to state 77
    NEQ             shift and go to state 78


state 128

    (67) index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .

    SEMI            reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    MOD             reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    AND             reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    OR              reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    LT              reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    GT              reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    LE              reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    GE              reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    EQ              reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    ID              reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    NOT             reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    FLOAT_LITERAL   reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    INT_LITERAL     reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    STRING_LITERAL  reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    BOOLEAN_LITERAL reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 67 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)

