Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration program
Rule 2     program -> definition program
Rule 3     program -> empty
Rule 4     declaration -> DECL ID LPAREN function_args RPAREN COLON return_type
Rule 5     definition -> DEF ID LPAREN function_args RPAREN COLON return_type block
Rule 6     function_args -> ID COLON var_type function_args
Rule 7     function_args -> COMMA function_args
Rule 8     function_args -> empty
Rule 9     return_type -> INT
Rule 10    return_type -> FLOAT
Rule 11    return_type -> STRING
Rule 12    return_type -> BOOLEAN
Rule 13    return_type -> VOID
Rule 14    return_type -> LBRACKET var_type RBRACKET
Rule 15    block -> LBRACE recursive_statement RBRACE
Rule 16    recursive_statement -> statement recursive_statement
Rule 17    recursive_statement -> empty
Rule 18    statement -> return_statement
Rule 19    statement -> expression SEMI
Rule 20    statement -> if_statement
Rule 21    statement -> while_statement
Rule 22    statement -> variable_declaration
Rule 23    statement -> variable_assignment
Rule 24    return_statement -> RETURN ret_value SEMI
Rule 25    ret_value -> expression
Rule 26    ret_value -> empty
Rule 27    if_statement -> IF expression block else_statement
Rule 28    else_statement -> ELSE block
Rule 29    else_statement -> empty
Rule 30    while_statement -> WHILE expression block
Rule 31    variable_declaration -> ID COLON var_type EQUALS expression SEMI
Rule 32    variable_assignment -> ID EQUALS expression SEMI
Rule 33    var_type -> FLOAT
Rule 34    var_type -> INT
Rule 35    var_type -> STRING
Rule 36    var_type -> BOOLEAN
Rule 37    var_type -> LBRACKET var_type RBRACKET
Rule 38    expression -> expression_binary_operation
Rule 39    expression -> expression_variable
Rule 40    expression -> expression_unary_operation
Rule 41    expression -> expression_literal
Rule 42    expression -> function_invocation
Rule 43    expression -> index_access
Rule 44    expression_binary_operation -> expression PLUS expression
Rule 45    expression_binary_operation -> expression MINUS expression
Rule 46    expression_binary_operation -> expression TIMES expression
Rule 47    expression_binary_operation -> expression DIVIDE expression
Rule 48    expression_binary_operation -> expression MOD expression
Rule 49    expression_binary_operation -> expression AND expression
Rule 50    expression_binary_operation -> expression OR expression
Rule 51    expression_binary_operation -> expression LT expression
Rule 52    expression_binary_operation -> expression GT expression
Rule 53    expression_binary_operation -> expression LE expression
Rule 54    expression_binary_operation -> expression GE expression
Rule 55    expression_binary_operation -> expression EQ expression
Rule 56    expression_binary_operation -> expression NEQ expression
Rule 57    expression_variable -> ID
Rule 58    expression_unary_operation -> NOT expression
Rule 59    expression_literal -> LBRACE array_literal RBRACE
Rule 60    expression_literal -> INT_LITERAL
Rule 61    expression_literal -> FLOAT_LITERAL
Rule 62    expression_literal -> STRING_LITERAL
Rule 63    expression_literal -> BOOLEAN_LITERAL
Rule 64    array_literal -> expression array_literal
Rule 65    array_literal -> COMMA array_literal
Rule 66    array_literal -> empty
Rule 67    function_invocation -> ID LPAREN func_invocation_args RPAREN
Rule 68    func_invocation_args -> expression func_invocation_args
Rule 69    func_invocation_args -> COMMA func_invocation_args
Rule 70    func_invocation_args -> empty
Rule 71    index_access -> ID index_access_aux
Rule 72    index_access_aux -> LBRACKET expression RBRACKET
Rule 73    index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET
Rule 74    empty -> <empty>

Terminals, with rules where they appear

AND                  : 49
BOOLEAN              : 12 36
BOOLEAN_LITERAL      : 63
COLON                : 4 5 6 31
COMMA                : 7 65 69
DECL                 : 4
DEF                  : 5
DIVIDE               : 47
ELSE                 : 28
EQ                   : 55
EQUALS               : 31 32
FLOAT                : 10 33
FLOAT_LITERAL        : 61
GE                   : 54
GT                   : 52
ID                   : 4 5 6 31 32 57 67 71
IF                   : 27
INT                  : 9 34
INT_LITERAL          : 60
LBRACE               : 15 59
LBRACKET             : 14 37 72 73
LE                   : 53
LPAREN               : 4 5 67 73
LT                   : 51
MINUS                : 45
MOD                  : 48
NEQ                  : 56
NOT                  : 58
OR                   : 50
PLUS                 : 44
RBRACE               : 15 59
RBRACKET             : 14 37 72 73
RETURN               : 24
RPAREN               : 4 5 67 73
SEMI                 : 19 24 31 32
STRING               : 11 35
STRING_LITERAL       : 62
TIMES                : 46
VOID                 : 13
WHILE                : 30
error                : 

Nonterminals, with rules where they appear

array_literal        : 59 64 65
block                : 5 27 28 30
declaration          : 1
definition           : 2
else_statement       : 27
empty                : 3 8 17 26 29 66 70
expression           : 19 25 27 30 31 32 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 58 64 68 72 73
expression_binary_operation : 38
expression_literal   : 41
expression_unary_operation : 40
expression_variable  : 39
func_invocation_args : 67 68 69 73
function_args        : 4 5 6 7
function_invocation  : 42
if_statement         : 20
index_access         : 43
index_access_aux     : 71
program              : 1 2 0
recursive_statement  : 15 16
ret_value            : 24
return_statement     : 18
return_type          : 4 5
statement            : 16
var_type             : 6 14 31 37
variable_assignment  : 23
variable_declaration : 22
while_statement      : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration program
    (2) program -> . definition program
    (3) program -> . empty
    (4) declaration -> . DECL ID LPAREN function_args RPAREN COLON return_type
    (5) definition -> . DEF ID LPAREN function_args RPAREN COLON return_type block
    (74) empty -> .

    DECL            shift and go to state 5
    DEF             shift and go to state 6
    $end            reduce using rule 74 (empty -> .)

    program                        shift and go to state 1
    declaration                    shift and go to state 2
    definition                     shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration . program
    (1) program -> . declaration program
    (2) program -> . definition program
    (3) program -> . empty
    (4) declaration -> . DECL ID LPAREN function_args RPAREN COLON return_type
    (5) definition -> . DEF ID LPAREN function_args RPAREN COLON return_type block
    (74) empty -> .

    DECL            shift and go to state 5
    DEF             shift and go to state 6
    $end            reduce using rule 74 (empty -> .)

    declaration                    shift and go to state 2
    program                        shift and go to state 7
    definition                     shift and go to state 3
    empty                          shift and go to state 4

state 3

    (2) program -> definition . program
    (1) program -> . declaration program
    (2) program -> . definition program
    (3) program -> . empty
    (4) declaration -> . DECL ID LPAREN function_args RPAREN COLON return_type
    (5) definition -> . DEF ID LPAREN function_args RPAREN COLON return_type block
    (74) empty -> .

    DECL            shift and go to state 5
    DEF             shift and go to state 6
    $end            reduce using rule 74 (empty -> .)

    definition                     shift and go to state 3
    program                        shift and go to state 8
    declaration                    shift and go to state 2
    empty                          shift and go to state 4

state 4

    (3) program -> empty .

    $end            reduce using rule 3 (program -> empty .)


state 5

    (4) declaration -> DECL . ID LPAREN function_args RPAREN COLON return_type

    ID              shift and go to state 9


state 6

    (5) definition -> DEF . ID LPAREN function_args RPAREN COLON return_type block

    ID              shift and go to state 10


state 7

    (1) program -> declaration program .

    $end            reduce using rule 1 (program -> declaration program .)


state 8

    (2) program -> definition program .

    $end            reduce using rule 2 (program -> definition program .)


state 9

    (4) declaration -> DECL ID . LPAREN function_args RPAREN COLON return_type

    LPAREN          shift and go to state 11


state 10

    (5) definition -> DEF ID . LPAREN function_args RPAREN COLON return_type block

    LPAREN          shift and go to state 12


state 11

    (4) declaration -> DECL ID LPAREN . function_args RPAREN COLON return_type
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (74) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 74 (empty -> .)

    function_args                  shift and go to state 14
    empty                          shift and go to state 16

state 12

    (5) definition -> DEF ID LPAREN . function_args RPAREN COLON return_type block
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (74) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 74 (empty -> .)

    function_args                  shift and go to state 17
    empty                          shift and go to state 16

state 13

    (6) function_args -> ID . COLON var_type function_args

    COLON           shift and go to state 18


state 14

    (4) declaration -> DECL ID LPAREN function_args . RPAREN COLON return_type

    RPAREN          shift and go to state 19


state 15

    (7) function_args -> COMMA . function_args
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (74) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 74 (empty -> .)

    function_args                  shift and go to state 20
    empty                          shift and go to state 16

state 16

    (8) function_args -> empty .

    RPAREN          reduce using rule 8 (function_args -> empty .)


state 17

    (5) definition -> DEF ID LPAREN function_args . RPAREN COLON return_type block

    RPAREN          shift and go to state 21


state 18

    (6) function_args -> ID COLON . var_type function_args
    (33) var_type -> . FLOAT
    (34) var_type -> . INT
    (35) var_type -> . STRING
    (36) var_type -> . BOOLEAN
    (37) var_type -> . LBRACKET var_type RBRACKET

    FLOAT           shift and go to state 23
    INT             shift and go to state 24
    STRING          shift and go to state 25
    BOOLEAN         shift and go to state 26
    LBRACKET        shift and go to state 27

    var_type                       shift and go to state 22

state 19

    (4) declaration -> DECL ID LPAREN function_args RPAREN . COLON return_type

    COLON           shift and go to state 28


state 20

    (7) function_args -> COMMA function_args .

    RPAREN          reduce using rule 7 (function_args -> COMMA function_args .)


state 21

    (5) definition -> DEF ID LPAREN function_args RPAREN . COLON return_type block

    COLON           shift and go to state 29


state 22

    (6) function_args -> ID COLON var_type . function_args
    (6) function_args -> . ID COLON var_type function_args
    (7) function_args -> . COMMA function_args
    (8) function_args -> . empty
    (74) empty -> .

    ID              shift and go to state 13
    COMMA           shift and go to state 15
    RPAREN          reduce using rule 74 (empty -> .)

    function_args                  shift and go to state 30
    empty                          shift and go to state 16

state 23

    (33) var_type -> FLOAT .

    ID              reduce using rule 33 (var_type -> FLOAT .)
    COMMA           reduce using rule 33 (var_type -> FLOAT .)
    RPAREN          reduce using rule 33 (var_type -> FLOAT .)
    RBRACKET        reduce using rule 33 (var_type -> FLOAT .)
    EQUALS          reduce using rule 33 (var_type -> FLOAT .)


state 24

    (34) var_type -> INT .

    ID              reduce using rule 34 (var_type -> INT .)
    COMMA           reduce using rule 34 (var_type -> INT .)
    RPAREN          reduce using rule 34 (var_type -> INT .)
    RBRACKET        reduce using rule 34 (var_type -> INT .)
    EQUALS          reduce using rule 34 (var_type -> INT .)


state 25

    (35) var_type -> STRING .

    ID              reduce using rule 35 (var_type -> STRING .)
    COMMA           reduce using rule 35 (var_type -> STRING .)
    RPAREN          reduce using rule 35 (var_type -> STRING .)
    RBRACKET        reduce using rule 35 (var_type -> STRING .)
    EQUALS          reduce using rule 35 (var_type -> STRING .)


state 26

    (36) var_type -> BOOLEAN .

    ID              reduce using rule 36 (var_type -> BOOLEAN .)
    COMMA           reduce using rule 36 (var_type -> BOOLEAN .)
    RPAREN          reduce using rule 36 (var_type -> BOOLEAN .)
    RBRACKET        reduce using rule 36 (var_type -> BOOLEAN .)
    EQUALS          reduce using rule 36 (var_type -> BOOLEAN .)


state 27

    (37) var_type -> LBRACKET . var_type RBRACKET
    (33) var_type -> . FLOAT
    (34) var_type -> . INT
    (35) var_type -> . STRING
    (36) var_type -> . BOOLEAN
    (37) var_type -> . LBRACKET var_type RBRACKET

    FLOAT           shift and go to state 23
    INT             shift and go to state 24
    STRING          shift and go to state 25
    BOOLEAN         shift and go to state 26
    LBRACKET        shift and go to state 27

    var_type                       shift and go to state 31

state 28

    (4) declaration -> DECL ID LPAREN function_args RPAREN COLON . return_type
    (9) return_type -> . INT
    (10) return_type -> . FLOAT
    (11) return_type -> . STRING
    (12) return_type -> . BOOLEAN
    (13) return_type -> . VOID
    (14) return_type -> . LBRACKET var_type RBRACKET

    INT             shift and go to state 33
    FLOAT           shift and go to state 34
    STRING          shift and go to state 35
    BOOLEAN         shift and go to state 36
    VOID            shift and go to state 37
    LBRACKET        shift and go to state 38

    return_type                    shift and go to state 32

state 29

    (5) definition -> DEF ID LPAREN function_args RPAREN COLON . return_type block
    (9) return_type -> . INT
    (10) return_type -> . FLOAT
    (11) return_type -> . STRING
    (12) return_type -> . BOOLEAN
    (13) return_type -> . VOID
    (14) return_type -> . LBRACKET var_type RBRACKET

    INT             shift and go to state 33
    FLOAT           shift and go to state 34
    STRING          shift and go to state 35
    BOOLEAN         shift and go to state 36
    VOID            shift and go to state 37
    LBRACKET        shift and go to state 38

    return_type                    shift and go to state 39

state 30

    (6) function_args -> ID COLON var_type function_args .

    RPAREN          reduce using rule 6 (function_args -> ID COLON var_type function_args .)


state 31

    (37) var_type -> LBRACKET var_type . RBRACKET

    RBRACKET        shift and go to state 40


state 32

    (4) declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .

    DECL            reduce using rule 4 (declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .)
    DEF             reduce using rule 4 (declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .)
    $end            reduce using rule 4 (declaration -> DECL ID LPAREN function_args RPAREN COLON return_type .)


state 33

    (9) return_type -> INT .

    DECL            reduce using rule 9 (return_type -> INT .)
    DEF             reduce using rule 9 (return_type -> INT .)
    $end            reduce using rule 9 (return_type -> INT .)
    LBRACE          reduce using rule 9 (return_type -> INT .)


state 34

    (10) return_type -> FLOAT .

    DECL            reduce using rule 10 (return_type -> FLOAT .)
    DEF             reduce using rule 10 (return_type -> FLOAT .)
    $end            reduce using rule 10 (return_type -> FLOAT .)
    LBRACE          reduce using rule 10 (return_type -> FLOAT .)


state 35

    (11) return_type -> STRING .

    DECL            reduce using rule 11 (return_type -> STRING .)
    DEF             reduce using rule 11 (return_type -> STRING .)
    $end            reduce using rule 11 (return_type -> STRING .)
    LBRACE          reduce using rule 11 (return_type -> STRING .)


state 36

    (12) return_type -> BOOLEAN .

    DECL            reduce using rule 12 (return_type -> BOOLEAN .)
    DEF             reduce using rule 12 (return_type -> BOOLEAN .)
    $end            reduce using rule 12 (return_type -> BOOLEAN .)
    LBRACE          reduce using rule 12 (return_type -> BOOLEAN .)


state 37

    (13) return_type -> VOID .

    DECL            reduce using rule 13 (return_type -> VOID .)
    DEF             reduce using rule 13 (return_type -> VOID .)
    $end            reduce using rule 13 (return_type -> VOID .)
    LBRACE          reduce using rule 13 (return_type -> VOID .)


state 38

    (14) return_type -> LBRACKET . var_type RBRACKET
    (33) var_type -> . FLOAT
    (34) var_type -> . INT
    (35) var_type -> . STRING
    (36) var_type -> . BOOLEAN
    (37) var_type -> . LBRACKET var_type RBRACKET

    FLOAT           shift and go to state 23
    INT             shift and go to state 24
    STRING          shift and go to state 25
    BOOLEAN         shift and go to state 26
    LBRACKET        shift and go to state 27

    var_type                       shift and go to state 41

state 39

    (5) definition -> DEF ID LPAREN function_args RPAREN COLON return_type . block
    (15) block -> . LBRACE recursive_statement RBRACE

    LBRACE          shift and go to state 43

    block                          shift and go to state 42

state 40

    (37) var_type -> LBRACKET var_type RBRACKET .

    ID              reduce using rule 37 (var_type -> LBRACKET var_type RBRACKET .)
    COMMA           reduce using rule 37 (var_type -> LBRACKET var_type RBRACKET .)
    RPAREN          reduce using rule 37 (var_type -> LBRACKET var_type RBRACKET .)
    RBRACKET        reduce using rule 37 (var_type -> LBRACKET var_type RBRACKET .)
    EQUALS          reduce using rule 37 (var_type -> LBRACKET var_type RBRACKET .)


state 41

    (14) return_type -> LBRACKET var_type . RBRACKET

    RBRACKET        shift and go to state 44


state 42

    (5) definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .

    DECL            reduce using rule 5 (definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .)
    DEF             reduce using rule 5 (definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .)
    $end            reduce using rule 5 (definition -> DEF ID LPAREN function_args RPAREN COLON return_type block .)


state 43

    (15) block -> LBRACE . recursive_statement RBRACE
    (16) recursive_statement -> . statement recursive_statement
    (17) recursive_statement -> . empty
    (18) statement -> . return_statement
    (19) statement -> . expression SEMI
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . variable_declaration
    (23) statement -> . variable_assignment
    (74) empty -> .
    (24) return_statement -> . RETURN ret_value SEMI
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (27) if_statement -> . IF expression block else_statement
    (30) while_statement -> . WHILE expression block
    (31) variable_declaration -> . ID COLON var_type EQUALS expression SEMI
    (32) variable_assignment -> . ID EQUALS expression SEMI
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    RBRACE          reduce using rule 74 (empty -> .)
    RETURN          shift and go to state 55
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    ID              shift and go to state 64
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    recursive_statement            shift and go to state 46
    statement                      shift and go to state 47
    empty                          shift and go to state 48
    return_statement               shift and go to state 49
    expression                     shift and go to state 50
    if_statement                   shift and go to state 51
    while_statement                shift and go to state 52
    variable_declaration           shift and go to state 53
    variable_assignment            shift and go to state 54
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 44

    (14) return_type -> LBRACKET var_type RBRACKET .

    DECL            reduce using rule 14 (return_type -> LBRACKET var_type RBRACKET .)
    DEF             reduce using rule 14 (return_type -> LBRACKET var_type RBRACKET .)
    $end            reduce using rule 14 (return_type -> LBRACKET var_type RBRACKET .)
    LBRACE          reduce using rule 14 (return_type -> LBRACKET var_type RBRACKET .)


state 45

    (59) expression_literal -> LBRACE . array_literal RBRACE
    (64) array_literal -> . expression array_literal
    (65) array_literal -> . COMMA array_literal
    (66) array_literal -> . empty
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (74) empty -> .
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    COMMA           shift and go to state 72
    RBRACE          reduce using rule 74 (empty -> .)
    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    array_literal                  shift and go to state 70
    expression                     shift and go to state 71
    empty                          shift and go to state 73
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 46

    (15) block -> LBRACE recursive_statement . RBRACE

    RBRACE          shift and go to state 75


state 47

    (16) recursive_statement -> statement . recursive_statement
    (16) recursive_statement -> . statement recursive_statement
    (17) recursive_statement -> . empty
    (18) statement -> . return_statement
    (19) statement -> . expression SEMI
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . variable_declaration
    (23) statement -> . variable_assignment
    (74) empty -> .
    (24) return_statement -> . RETURN ret_value SEMI
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (27) if_statement -> . IF expression block else_statement
    (30) while_statement -> . WHILE expression block
    (31) variable_declaration -> . ID COLON var_type EQUALS expression SEMI
    (32) variable_assignment -> . ID EQUALS expression SEMI
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    RBRACE          reduce using rule 74 (empty -> .)
    RETURN          shift and go to state 55
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    ID              shift and go to state 64
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    statement                      shift and go to state 47
    recursive_statement            shift and go to state 76
    empty                          shift and go to state 48
    return_statement               shift and go to state 49
    expression                     shift and go to state 50
    if_statement                   shift and go to state 51
    while_statement                shift and go to state 52
    variable_declaration           shift and go to state 53
    variable_assignment            shift and go to state 54
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 48

    (17) recursive_statement -> empty .

    RBRACE          reduce using rule 17 (recursive_statement -> empty .)


state 49

    (18) statement -> return_statement .

    RETURN          reduce using rule 18 (statement -> return_statement .)
    IF              reduce using rule 18 (statement -> return_statement .)
    WHILE           reduce using rule 18 (statement -> return_statement .)
    ID              reduce using rule 18 (statement -> return_statement .)
    NOT             reduce using rule 18 (statement -> return_statement .)
    LBRACE          reduce using rule 18 (statement -> return_statement .)
    INT_LITERAL     reduce using rule 18 (statement -> return_statement .)
    FLOAT_LITERAL   reduce using rule 18 (statement -> return_statement .)
    STRING_LITERAL  reduce using rule 18 (statement -> return_statement .)
    BOOLEAN_LITERAL reduce using rule 18 (statement -> return_statement .)
    RBRACE          reduce using rule 18 (statement -> return_statement .)


state 50

    (19) statement -> expression . SEMI
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 51

    (20) statement -> if_statement .

    RETURN          reduce using rule 20 (statement -> if_statement .)
    IF              reduce using rule 20 (statement -> if_statement .)
    WHILE           reduce using rule 20 (statement -> if_statement .)
    ID              reduce using rule 20 (statement -> if_statement .)
    NOT             reduce using rule 20 (statement -> if_statement .)
    LBRACE          reduce using rule 20 (statement -> if_statement .)
    INT_LITERAL     reduce using rule 20 (statement -> if_statement .)
    FLOAT_LITERAL   reduce using rule 20 (statement -> if_statement .)
    STRING_LITERAL  reduce using rule 20 (statement -> if_statement .)
    BOOLEAN_LITERAL reduce using rule 20 (statement -> if_statement .)
    RBRACE          reduce using rule 20 (statement -> if_statement .)


state 52

    (21) statement -> while_statement .

    RETURN          reduce using rule 21 (statement -> while_statement .)
    IF              reduce using rule 21 (statement -> while_statement .)
    WHILE           reduce using rule 21 (statement -> while_statement .)
    ID              reduce using rule 21 (statement -> while_statement .)
    NOT             reduce using rule 21 (statement -> while_statement .)
    LBRACE          reduce using rule 21 (statement -> while_statement .)
    INT_LITERAL     reduce using rule 21 (statement -> while_statement .)
    FLOAT_LITERAL   reduce using rule 21 (statement -> while_statement .)
    STRING_LITERAL  reduce using rule 21 (statement -> while_statement .)
    BOOLEAN_LITERAL reduce using rule 21 (statement -> while_statement .)
    RBRACE          reduce using rule 21 (statement -> while_statement .)


state 53

    (22) statement -> variable_declaration .

    RETURN          reduce using rule 22 (statement -> variable_declaration .)
    IF              reduce using rule 22 (statement -> variable_declaration .)
    WHILE           reduce using rule 22 (statement -> variable_declaration .)
    ID              reduce using rule 22 (statement -> variable_declaration .)
    NOT             reduce using rule 22 (statement -> variable_declaration .)
    LBRACE          reduce using rule 22 (statement -> variable_declaration .)
    INT_LITERAL     reduce using rule 22 (statement -> variable_declaration .)
    FLOAT_LITERAL   reduce using rule 22 (statement -> variable_declaration .)
    STRING_LITERAL  reduce using rule 22 (statement -> variable_declaration .)
    BOOLEAN_LITERAL reduce using rule 22 (statement -> variable_declaration .)
    RBRACE          reduce using rule 22 (statement -> variable_declaration .)


state 54

    (23) statement -> variable_assignment .

    RETURN          reduce using rule 23 (statement -> variable_assignment .)
    IF              reduce using rule 23 (statement -> variable_assignment .)
    WHILE           reduce using rule 23 (statement -> variable_assignment .)
    ID              reduce using rule 23 (statement -> variable_assignment .)
    NOT             reduce using rule 23 (statement -> variable_assignment .)
    LBRACE          reduce using rule 23 (statement -> variable_assignment .)
    INT_LITERAL     reduce using rule 23 (statement -> variable_assignment .)
    FLOAT_LITERAL   reduce using rule 23 (statement -> variable_assignment .)
    STRING_LITERAL  reduce using rule 23 (statement -> variable_assignment .)
    BOOLEAN_LITERAL reduce using rule 23 (statement -> variable_assignment .)
    RBRACE          reduce using rule 23 (statement -> variable_assignment .)


state 55

    (24) return_statement -> RETURN . ret_value SEMI
    (25) ret_value -> . expression
    (26) ret_value -> . empty
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (74) empty -> .
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    SEMI            reduce using rule 74 (empty -> .)
    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    ret_value                      shift and go to state 91
    expression                     shift and go to state 92
    empty                          shift and go to state 93
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 56

    (38) expression -> expression_binary_operation .

    SEMI            reduce using rule 38 (expression -> expression_binary_operation .)
    PLUS            reduce using rule 38 (expression -> expression_binary_operation .)
    MINUS           reduce using rule 38 (expression -> expression_binary_operation .)
    TIMES           reduce using rule 38 (expression -> expression_binary_operation .)
    DIVIDE          reduce using rule 38 (expression -> expression_binary_operation .)
    MOD             reduce using rule 38 (expression -> expression_binary_operation .)
    AND             reduce using rule 38 (expression -> expression_binary_operation .)
    OR              reduce using rule 38 (expression -> expression_binary_operation .)
    LT              reduce using rule 38 (expression -> expression_binary_operation .)
    GT              reduce using rule 38 (expression -> expression_binary_operation .)
    LE              reduce using rule 38 (expression -> expression_binary_operation .)
    GE              reduce using rule 38 (expression -> expression_binary_operation .)
    EQ              reduce using rule 38 (expression -> expression_binary_operation .)
    NEQ             reduce using rule 38 (expression -> expression_binary_operation .)
    COMMA           reduce using rule 38 (expression -> expression_binary_operation .)
    ID              reduce using rule 38 (expression -> expression_binary_operation .)
    NOT             reduce using rule 38 (expression -> expression_binary_operation .)
    LBRACE          reduce using rule 38 (expression -> expression_binary_operation .)
    INT_LITERAL     reduce using rule 38 (expression -> expression_binary_operation .)
    FLOAT_LITERAL   reduce using rule 38 (expression -> expression_binary_operation .)
    STRING_LITERAL  reduce using rule 38 (expression -> expression_binary_operation .)
    BOOLEAN_LITERAL reduce using rule 38 (expression -> expression_binary_operation .)
    RBRACE          reduce using rule 38 (expression -> expression_binary_operation .)
    RPAREN          reduce using rule 38 (expression -> expression_binary_operation .)
    RBRACKET        reduce using rule 38 (expression -> expression_binary_operation .)


state 57

    (39) expression -> expression_variable .

    SEMI            reduce using rule 39 (expression -> expression_variable .)
    PLUS            reduce using rule 39 (expression -> expression_variable .)
    MINUS           reduce using rule 39 (expression -> expression_variable .)
    TIMES           reduce using rule 39 (expression -> expression_variable .)
    DIVIDE          reduce using rule 39 (expression -> expression_variable .)
    MOD             reduce using rule 39 (expression -> expression_variable .)
    AND             reduce using rule 39 (expression -> expression_variable .)
    OR              reduce using rule 39 (expression -> expression_variable .)
    LT              reduce using rule 39 (expression -> expression_variable .)
    GT              reduce using rule 39 (expression -> expression_variable .)
    LE              reduce using rule 39 (expression -> expression_variable .)
    GE              reduce using rule 39 (expression -> expression_variable .)
    EQ              reduce using rule 39 (expression -> expression_variable .)
    NEQ             reduce using rule 39 (expression -> expression_variable .)
    COMMA           reduce using rule 39 (expression -> expression_variable .)
    ID              reduce using rule 39 (expression -> expression_variable .)
    NOT             reduce using rule 39 (expression -> expression_variable .)
    LBRACE          reduce using rule 39 (expression -> expression_variable .)
    INT_LITERAL     reduce using rule 39 (expression -> expression_variable .)
    FLOAT_LITERAL   reduce using rule 39 (expression -> expression_variable .)
    STRING_LITERAL  reduce using rule 39 (expression -> expression_variable .)
    BOOLEAN_LITERAL reduce using rule 39 (expression -> expression_variable .)
    RBRACE          reduce using rule 39 (expression -> expression_variable .)
    RPAREN          reduce using rule 39 (expression -> expression_variable .)
    RBRACKET        reduce using rule 39 (expression -> expression_variable .)


state 58

    (40) expression -> expression_unary_operation .

    SEMI            reduce using rule 40 (expression -> expression_unary_operation .)
    PLUS            reduce using rule 40 (expression -> expression_unary_operation .)
    MINUS           reduce using rule 40 (expression -> expression_unary_operation .)
    TIMES           reduce using rule 40 (expression -> expression_unary_operation .)
    DIVIDE          reduce using rule 40 (expression -> expression_unary_operation .)
    MOD             reduce using rule 40 (expression -> expression_unary_operation .)
    AND             reduce using rule 40 (expression -> expression_unary_operation .)
    OR              reduce using rule 40 (expression -> expression_unary_operation .)
    LT              reduce using rule 40 (expression -> expression_unary_operation .)
    GT              reduce using rule 40 (expression -> expression_unary_operation .)
    LE              reduce using rule 40 (expression -> expression_unary_operation .)
    GE              reduce using rule 40 (expression -> expression_unary_operation .)
    EQ              reduce using rule 40 (expression -> expression_unary_operation .)
    NEQ             reduce using rule 40 (expression -> expression_unary_operation .)
    COMMA           reduce using rule 40 (expression -> expression_unary_operation .)
    ID              reduce using rule 40 (expression -> expression_unary_operation .)
    NOT             reduce using rule 40 (expression -> expression_unary_operation .)
    LBRACE          reduce using rule 40 (expression -> expression_unary_operation .)
    INT_LITERAL     reduce using rule 40 (expression -> expression_unary_operation .)
    FLOAT_LITERAL   reduce using rule 40 (expression -> expression_unary_operation .)
    STRING_LITERAL  reduce using rule 40 (expression -> expression_unary_operation .)
    BOOLEAN_LITERAL reduce using rule 40 (expression -> expression_unary_operation .)
    RBRACE          reduce using rule 40 (expression -> expression_unary_operation .)
    RPAREN          reduce using rule 40 (expression -> expression_unary_operation .)
    RBRACKET        reduce using rule 40 (expression -> expression_unary_operation .)


state 59

    (41) expression -> expression_literal .

    SEMI            reduce using rule 41 (expression -> expression_literal .)
    PLUS            reduce using rule 41 (expression -> expression_literal .)
    MINUS           reduce using rule 41 (expression -> expression_literal .)
    TIMES           reduce using rule 41 (expression -> expression_literal .)
    DIVIDE          reduce using rule 41 (expression -> expression_literal .)
    MOD             reduce using rule 41 (expression -> expression_literal .)
    AND             reduce using rule 41 (expression -> expression_literal .)
    OR              reduce using rule 41 (expression -> expression_literal .)
    LT              reduce using rule 41 (expression -> expression_literal .)
    GT              reduce using rule 41 (expression -> expression_literal .)
    LE              reduce using rule 41 (expression -> expression_literal .)
    GE              reduce using rule 41 (expression -> expression_literal .)
    EQ              reduce using rule 41 (expression -> expression_literal .)
    NEQ             reduce using rule 41 (expression -> expression_literal .)
    COMMA           reduce using rule 41 (expression -> expression_literal .)
    ID              reduce using rule 41 (expression -> expression_literal .)
    NOT             reduce using rule 41 (expression -> expression_literal .)
    LBRACE          reduce using rule 41 (expression -> expression_literal .)
    INT_LITERAL     reduce using rule 41 (expression -> expression_literal .)
    FLOAT_LITERAL   reduce using rule 41 (expression -> expression_literal .)
    STRING_LITERAL  reduce using rule 41 (expression -> expression_literal .)
    BOOLEAN_LITERAL reduce using rule 41 (expression -> expression_literal .)
    RBRACE          reduce using rule 41 (expression -> expression_literal .)
    RPAREN          reduce using rule 41 (expression -> expression_literal .)
    RBRACKET        reduce using rule 41 (expression -> expression_literal .)


state 60

    (42) expression -> function_invocation .

    SEMI            reduce using rule 42 (expression -> function_invocation .)
    PLUS            reduce using rule 42 (expression -> function_invocation .)
    MINUS           reduce using rule 42 (expression -> function_invocation .)
    TIMES           reduce using rule 42 (expression -> function_invocation .)
    DIVIDE          reduce using rule 42 (expression -> function_invocation .)
    MOD             reduce using rule 42 (expression -> function_invocation .)
    AND             reduce using rule 42 (expression -> function_invocation .)
    OR              reduce using rule 42 (expression -> function_invocation .)
    LT              reduce using rule 42 (expression -> function_invocation .)
    GT              reduce using rule 42 (expression -> function_invocation .)
    LE              reduce using rule 42 (expression -> function_invocation .)
    GE              reduce using rule 42 (expression -> function_invocation .)
    EQ              reduce using rule 42 (expression -> function_invocation .)
    NEQ             reduce using rule 42 (expression -> function_invocation .)
    COMMA           reduce using rule 42 (expression -> function_invocation .)
    ID              reduce using rule 42 (expression -> function_invocation .)
    NOT             reduce using rule 42 (expression -> function_invocation .)
    LBRACE          reduce using rule 42 (expression -> function_invocation .)
    INT_LITERAL     reduce using rule 42 (expression -> function_invocation .)
    FLOAT_LITERAL   reduce using rule 42 (expression -> function_invocation .)
    STRING_LITERAL  reduce using rule 42 (expression -> function_invocation .)
    BOOLEAN_LITERAL reduce using rule 42 (expression -> function_invocation .)
    RBRACE          reduce using rule 42 (expression -> function_invocation .)
    RPAREN          reduce using rule 42 (expression -> function_invocation .)
    RBRACKET        reduce using rule 42 (expression -> function_invocation .)


state 61

    (43) expression -> index_access .

    SEMI            reduce using rule 43 (expression -> index_access .)
    PLUS            reduce using rule 43 (expression -> index_access .)
    MINUS           reduce using rule 43 (expression -> index_access .)
    TIMES           reduce using rule 43 (expression -> index_access .)
    DIVIDE          reduce using rule 43 (expression -> index_access .)
    MOD             reduce using rule 43 (expression -> index_access .)
    AND             reduce using rule 43 (expression -> index_access .)
    OR              reduce using rule 43 (expression -> index_access .)
    LT              reduce using rule 43 (expression -> index_access .)
    GT              reduce using rule 43 (expression -> index_access .)
    LE              reduce using rule 43 (expression -> index_access .)
    GE              reduce using rule 43 (expression -> index_access .)
    EQ              reduce using rule 43 (expression -> index_access .)
    NEQ             reduce using rule 43 (expression -> index_access .)
    COMMA           reduce using rule 43 (expression -> index_access .)
    ID              reduce using rule 43 (expression -> index_access .)
    NOT             reduce using rule 43 (expression -> index_access .)
    LBRACE          reduce using rule 43 (expression -> index_access .)
    INT_LITERAL     reduce using rule 43 (expression -> index_access .)
    FLOAT_LITERAL   reduce using rule 43 (expression -> index_access .)
    STRING_LITERAL  reduce using rule 43 (expression -> index_access .)
    BOOLEAN_LITERAL reduce using rule 43 (expression -> index_access .)
    RBRACE          reduce using rule 43 (expression -> index_access .)
    RPAREN          reduce using rule 43 (expression -> index_access .)
    RBRACKET        reduce using rule 43 (expression -> index_access .)


state 62

    (27) if_statement -> IF . expression block else_statement
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 94
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 63

    (30) while_statement -> WHILE . expression block
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 95
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 64

    (31) variable_declaration -> ID . COLON var_type EQUALS expression SEMI
    (32) variable_assignment -> ID . EQUALS expression SEMI
    (57) expression_variable -> ID .
    (67) function_invocation -> ID . LPAREN func_invocation_args RPAREN
    (71) index_access -> ID . index_access_aux
    (72) index_access_aux -> . LBRACKET expression RBRACKET
    (73) index_access_aux -> . LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET

    COLON           shift and go to state 96
    EQUALS          shift and go to state 97
    SEMI            reduce using rule 57 (expression_variable -> ID .)
    PLUS            reduce using rule 57 (expression_variable -> ID .)
    MINUS           reduce using rule 57 (expression_variable -> ID .)
    TIMES           reduce using rule 57 (expression_variable -> ID .)
    DIVIDE          reduce using rule 57 (expression_variable -> ID .)
    MOD             reduce using rule 57 (expression_variable -> ID .)
    AND             reduce using rule 57 (expression_variable -> ID .)
    OR              reduce using rule 57 (expression_variable -> ID .)
    LT              reduce using rule 57 (expression_variable -> ID .)
    GT              reduce using rule 57 (expression_variable -> ID .)
    LE              reduce using rule 57 (expression_variable -> ID .)
    GE              reduce using rule 57 (expression_variable -> ID .)
    EQ              reduce using rule 57 (expression_variable -> ID .)
    NEQ             reduce using rule 57 (expression_variable -> ID .)
    LPAREN          shift and go to state 98
    LBRACKET        shift and go to state 100

    index_access_aux               shift and go to state 99

state 65

    (58) expression_unary_operation -> NOT . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 101
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 66

    (60) expression_literal -> INT_LITERAL .

    SEMI            reduce using rule 60 (expression_literal -> INT_LITERAL .)
    PLUS            reduce using rule 60 (expression_literal -> INT_LITERAL .)
    MINUS           reduce using rule 60 (expression_literal -> INT_LITERAL .)
    TIMES           reduce using rule 60 (expression_literal -> INT_LITERAL .)
    DIVIDE          reduce using rule 60 (expression_literal -> INT_LITERAL .)
    MOD             reduce using rule 60 (expression_literal -> INT_LITERAL .)
    AND             reduce using rule 60 (expression_literal -> INT_LITERAL .)
    OR              reduce using rule 60 (expression_literal -> INT_LITERAL .)
    LT              reduce using rule 60 (expression_literal -> INT_LITERAL .)
    GT              reduce using rule 60 (expression_literal -> INT_LITERAL .)
    LE              reduce using rule 60 (expression_literal -> INT_LITERAL .)
    GE              reduce using rule 60 (expression_literal -> INT_LITERAL .)
    EQ              reduce using rule 60 (expression_literal -> INT_LITERAL .)
    NEQ             reduce using rule 60 (expression_literal -> INT_LITERAL .)
    COMMA           reduce using rule 60 (expression_literal -> INT_LITERAL .)
    ID              reduce using rule 60 (expression_literal -> INT_LITERAL .)
    NOT             reduce using rule 60 (expression_literal -> INT_LITERAL .)
    LBRACE          reduce using rule 60 (expression_literal -> INT_LITERAL .)
    INT_LITERAL     reduce using rule 60 (expression_literal -> INT_LITERAL .)
    FLOAT_LITERAL   reduce using rule 60 (expression_literal -> INT_LITERAL .)
    STRING_LITERAL  reduce using rule 60 (expression_literal -> INT_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 60 (expression_literal -> INT_LITERAL .)
    RBRACE          reduce using rule 60 (expression_literal -> INT_LITERAL .)
    RPAREN          reduce using rule 60 (expression_literal -> INT_LITERAL .)
    RBRACKET        reduce using rule 60 (expression_literal -> INT_LITERAL .)


state 67

    (61) expression_literal -> FLOAT_LITERAL .

    SEMI            reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    PLUS            reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    MINUS           reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    TIMES           reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    MOD             reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    AND             reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    OR              reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    LT              reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    GT              reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    LE              reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    GE              reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    EQ              reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    NEQ             reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    COMMA           reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    ID              reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    NOT             reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    LBRACE          reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    INT_LITERAL     reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    FLOAT_LITERAL   reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    STRING_LITERAL  reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    RBRACE          reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)
    RBRACKET        reduce using rule 61 (expression_literal -> FLOAT_LITERAL .)


state 68

    (62) expression_literal -> STRING_LITERAL .

    SEMI            reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    PLUS            reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    MINUS           reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    TIMES           reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    MOD             reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    AND             reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    OR              reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    LT              reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    GT              reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    LE              reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    GE              reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    EQ              reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    NEQ             reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    COMMA           reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    ID              reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    NOT             reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    LBRACE          reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    INT_LITERAL     reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    FLOAT_LITERAL   reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    RBRACE          reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 62 (expression_literal -> STRING_LITERAL .)
    RBRACKET        reduce using rule 62 (expression_literal -> STRING_LITERAL .)


state 69

    (63) expression_literal -> BOOLEAN_LITERAL .

    SEMI            reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    PLUS            reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    MINUS           reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    TIMES           reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    DIVIDE          reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    MOD             reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    AND             reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    OR              reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    LT              reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    GT              reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    LE              reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    GE              reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    EQ              reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    NEQ             reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    COMMA           reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    ID              reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    NOT             reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    LBRACE          reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    INT_LITERAL     reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    FLOAT_LITERAL   reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    STRING_LITERAL  reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    BOOLEAN_LITERAL reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    RBRACE          reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    RPAREN          reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)
    RBRACKET        reduce using rule 63 (expression_literal -> BOOLEAN_LITERAL .)


state 70

    (59) expression_literal -> LBRACE array_literal . RBRACE

    RBRACE          shift and go to state 102


state 71

    (64) array_literal -> expression . array_literal
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression
    (64) array_literal -> . expression array_literal
    (65) array_literal -> . COMMA array_literal
    (66) array_literal -> . empty
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (74) empty -> .
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    COMMA           shift and go to state 72
    RBRACE          reduce using rule 74 (empty -> .)
    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 71
    array_literal                  shift and go to state 103
    empty                          shift and go to state 73
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 72

    (65) array_literal -> COMMA . array_literal
    (64) array_literal -> . expression array_literal
    (65) array_literal -> . COMMA array_literal
    (66) array_literal -> . empty
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (74) empty -> .
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    COMMA           shift and go to state 72
    RBRACE          reduce using rule 74 (empty -> .)
    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    array_literal                  shift and go to state 104
    expression                     shift and go to state 71
    empty                          shift and go to state 73
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 73

    (66) array_literal -> empty .

    RBRACE          reduce using rule 66 (array_literal -> empty .)


state 74

    (57) expression_variable -> ID .
    (67) function_invocation -> ID . LPAREN func_invocation_args RPAREN
    (71) index_access -> ID . index_access_aux
    (72) index_access_aux -> . LBRACKET expression RBRACKET
    (73) index_access_aux -> . LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET

    PLUS            reduce using rule 57 (expression_variable -> ID .)
    MINUS           reduce using rule 57 (expression_variable -> ID .)
    TIMES           reduce using rule 57 (expression_variable -> ID .)
    DIVIDE          reduce using rule 57 (expression_variable -> ID .)
    MOD             reduce using rule 57 (expression_variable -> ID .)
    AND             reduce using rule 57 (expression_variable -> ID .)
    OR              reduce using rule 57 (expression_variable -> ID .)
    LT              reduce using rule 57 (expression_variable -> ID .)
    GT              reduce using rule 57 (expression_variable -> ID .)
    LE              reduce using rule 57 (expression_variable -> ID .)
    GE              reduce using rule 57 (expression_variable -> ID .)
    EQ              reduce using rule 57 (expression_variable -> ID .)
    NEQ             reduce using rule 57 (expression_variable -> ID .)
    COMMA           reduce using rule 57 (expression_variable -> ID .)
    ID              reduce using rule 57 (expression_variable -> ID .)
    NOT             reduce using rule 57 (expression_variable -> ID .)
    LBRACE          reduce using rule 57 (expression_variable -> ID .)
    INT_LITERAL     reduce using rule 57 (expression_variable -> ID .)
    FLOAT_LITERAL   reduce using rule 57 (expression_variable -> ID .)
    STRING_LITERAL  reduce using rule 57 (expression_variable -> ID .)
    BOOLEAN_LITERAL reduce using rule 57 (expression_variable -> ID .)
    RBRACE          reduce using rule 57 (expression_variable -> ID .)
    SEMI            reduce using rule 57 (expression_variable -> ID .)
    RPAREN          reduce using rule 57 (expression_variable -> ID .)
    RBRACKET        reduce using rule 57 (expression_variable -> ID .)
    LPAREN          shift and go to state 98
    LBRACKET        shift and go to state 100

    index_access_aux               shift and go to state 99

state 75

    (15) block -> LBRACE recursive_statement RBRACE .

    DECL            reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    DEF             reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    $end            reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    ELSE            reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    RETURN          reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    IF              reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    WHILE           reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    ID              reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    NOT             reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    LBRACE          reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    INT_LITERAL     reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    FLOAT_LITERAL   reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    STRING_LITERAL  reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    BOOLEAN_LITERAL reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)
    RBRACE          reduce using rule 15 (block -> LBRACE recursive_statement RBRACE .)


state 76

    (16) recursive_statement -> statement recursive_statement .

    RBRACE          reduce using rule 16 (recursive_statement -> statement recursive_statement .)


state 77

    (19) statement -> expression SEMI .

    RETURN          reduce using rule 19 (statement -> expression SEMI .)
    IF              reduce using rule 19 (statement -> expression SEMI .)
    WHILE           reduce using rule 19 (statement -> expression SEMI .)
    ID              reduce using rule 19 (statement -> expression SEMI .)
    NOT             reduce using rule 19 (statement -> expression SEMI .)
    LBRACE          reduce using rule 19 (statement -> expression SEMI .)
    INT_LITERAL     reduce using rule 19 (statement -> expression SEMI .)
    FLOAT_LITERAL   reduce using rule 19 (statement -> expression SEMI .)
    STRING_LITERAL  reduce using rule 19 (statement -> expression SEMI .)
    BOOLEAN_LITERAL reduce using rule 19 (statement -> expression SEMI .)
    RBRACE          reduce using rule 19 (statement -> expression SEMI .)


state 78

    (44) expression_binary_operation -> expression PLUS . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 105
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 79

    (45) expression_binary_operation -> expression MINUS . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 106
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 80

    (46) expression_binary_operation -> expression TIMES . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 107
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 81

    (47) expression_binary_operation -> expression DIVIDE . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 108
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 82

    (48) expression_binary_operation -> expression MOD . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 109
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 83

    (49) expression_binary_operation -> expression AND . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 110
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 84

    (50) expression_binary_operation -> expression OR . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 111
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 85

    (51) expression_binary_operation -> expression LT . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 112
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 86

    (52) expression_binary_operation -> expression GT . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 113
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 87

    (53) expression_binary_operation -> expression LE . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 114
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 88

    (54) expression_binary_operation -> expression GE . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 115
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 89

    (55) expression_binary_operation -> expression EQ . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 116
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 90

    (56) expression_binary_operation -> expression NEQ . expression
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 117
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 91

    (24) return_statement -> RETURN ret_value . SEMI

    SEMI            shift and go to state 118


state 92

    (25) ret_value -> expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 25 (ret_value -> expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 93

    (26) ret_value -> empty .

    SEMI            reduce using rule 26 (ret_value -> empty .)


state 94

    (27) if_statement -> IF expression . block else_statement
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression
    (15) block -> . LBRACE recursive_statement RBRACE

    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LBRACE          shift and go to state 43

    block                          shift and go to state 119

state 95

    (30) while_statement -> WHILE expression . block
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression
    (15) block -> . LBRACE recursive_statement RBRACE

    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LBRACE          shift and go to state 43

    block                          shift and go to state 120

state 96

    (31) variable_declaration -> ID COLON . var_type EQUALS expression SEMI
    (33) var_type -> . FLOAT
    (34) var_type -> . INT
    (35) var_type -> . STRING
    (36) var_type -> . BOOLEAN
    (37) var_type -> . LBRACKET var_type RBRACKET

    FLOAT           shift and go to state 23
    INT             shift and go to state 24
    STRING          shift and go to state 25
    BOOLEAN         shift and go to state 26
    LBRACKET        shift and go to state 27

    var_type                       shift and go to state 121

state 97

    (32) variable_assignment -> ID EQUALS . expression SEMI
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 122
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 98

    (67) function_invocation -> ID LPAREN . func_invocation_args RPAREN
    (73) index_access_aux -> LPAREN . func_invocation_args RPAREN LBRACKET expression RBRACKET
    (68) func_invocation_args -> . expression func_invocation_args
    (69) func_invocation_args -> . COMMA func_invocation_args
    (70) func_invocation_args -> . empty
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (74) empty -> .
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    COMMA           shift and go to state 125
    RPAREN          reduce using rule 74 (empty -> .)
    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    func_invocation_args           shift and go to state 123
    expression                     shift and go to state 124
    empty                          shift and go to state 126
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 99

    (71) index_access -> ID index_access_aux .

    SEMI            reduce using rule 71 (index_access -> ID index_access_aux .)
    PLUS            reduce using rule 71 (index_access -> ID index_access_aux .)
    MINUS           reduce using rule 71 (index_access -> ID index_access_aux .)
    TIMES           reduce using rule 71 (index_access -> ID index_access_aux .)
    DIVIDE          reduce using rule 71 (index_access -> ID index_access_aux .)
    MOD             reduce using rule 71 (index_access -> ID index_access_aux .)
    AND             reduce using rule 71 (index_access -> ID index_access_aux .)
    OR              reduce using rule 71 (index_access -> ID index_access_aux .)
    LT              reduce using rule 71 (index_access -> ID index_access_aux .)
    GT              reduce using rule 71 (index_access -> ID index_access_aux .)
    LE              reduce using rule 71 (index_access -> ID index_access_aux .)
    GE              reduce using rule 71 (index_access -> ID index_access_aux .)
    EQ              reduce using rule 71 (index_access -> ID index_access_aux .)
    NEQ             reduce using rule 71 (index_access -> ID index_access_aux .)
    COMMA           reduce using rule 71 (index_access -> ID index_access_aux .)
    ID              reduce using rule 71 (index_access -> ID index_access_aux .)
    NOT             reduce using rule 71 (index_access -> ID index_access_aux .)
    LBRACE          reduce using rule 71 (index_access -> ID index_access_aux .)
    INT_LITERAL     reduce using rule 71 (index_access -> ID index_access_aux .)
    FLOAT_LITERAL   reduce using rule 71 (index_access -> ID index_access_aux .)
    STRING_LITERAL  reduce using rule 71 (index_access -> ID index_access_aux .)
    BOOLEAN_LITERAL reduce using rule 71 (index_access -> ID index_access_aux .)
    RBRACE          reduce using rule 71 (index_access -> ID index_access_aux .)
    RPAREN          reduce using rule 71 (index_access -> ID index_access_aux .)
    RBRACKET        reduce using rule 71 (index_access -> ID index_access_aux .)


state 100

    (72) index_access_aux -> LBRACKET . expression RBRACKET
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 127
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 101

    (58) expression_unary_operation -> NOT expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 58 (expression_unary_operation -> NOT expression .)
    PLUS            reduce using rule 58 (expression_unary_operation -> NOT expression .)
    MINUS           reduce using rule 58 (expression_unary_operation -> NOT expression .)
    TIMES           reduce using rule 58 (expression_unary_operation -> NOT expression .)
    DIVIDE          reduce using rule 58 (expression_unary_operation -> NOT expression .)
    MOD             reduce using rule 58 (expression_unary_operation -> NOT expression .)
    AND             reduce using rule 58 (expression_unary_operation -> NOT expression .)
    OR              reduce using rule 58 (expression_unary_operation -> NOT expression .)
    LT              reduce using rule 58 (expression_unary_operation -> NOT expression .)
    GT              reduce using rule 58 (expression_unary_operation -> NOT expression .)
    LE              reduce using rule 58 (expression_unary_operation -> NOT expression .)
    GE              reduce using rule 58 (expression_unary_operation -> NOT expression .)
    EQ              reduce using rule 58 (expression_unary_operation -> NOT expression .)
    NEQ             reduce using rule 58 (expression_unary_operation -> NOT expression .)
    COMMA           reduce using rule 58 (expression_unary_operation -> NOT expression .)
    ID              reduce using rule 58 (expression_unary_operation -> NOT expression .)
    NOT             reduce using rule 58 (expression_unary_operation -> NOT expression .)
    LBRACE          reduce using rule 58 (expression_unary_operation -> NOT expression .)
    INT_LITERAL     reduce using rule 58 (expression_unary_operation -> NOT expression .)
    FLOAT_LITERAL   reduce using rule 58 (expression_unary_operation -> NOT expression .)
    STRING_LITERAL  reduce using rule 58 (expression_unary_operation -> NOT expression .)
    BOOLEAN_LITERAL reduce using rule 58 (expression_unary_operation -> NOT expression .)
    RBRACE          reduce using rule 58 (expression_unary_operation -> NOT expression .)
    RPAREN          reduce using rule 58 (expression_unary_operation -> NOT expression .)
    RBRACKET        reduce using rule 58 (expression_unary_operation -> NOT expression .)

  ! PLUS            [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 80 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! MOD             [ shift and go to state 82 ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 102

    (59) expression_literal -> LBRACE array_literal RBRACE .

    SEMI            reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    PLUS            reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    MINUS           reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    TIMES           reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    DIVIDE          reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    MOD             reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    AND             reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    OR              reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    LT              reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    GT              reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    LE              reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    GE              reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    EQ              reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    NEQ             reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    COMMA           reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    ID              reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    NOT             reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    LBRACE          reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    INT_LITERAL     reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    FLOAT_LITERAL   reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    STRING_LITERAL  reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    BOOLEAN_LITERAL reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    RBRACE          reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    RPAREN          reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)
    RBRACKET        reduce using rule 59 (expression_literal -> LBRACE array_literal RBRACE .)


state 103

    (64) array_literal -> expression array_literal .

    RBRACE          reduce using rule 64 (array_literal -> expression array_literal .)


state 104

    (65) array_literal -> COMMA array_literal .

    RBRACE          reduce using rule 65 (array_literal -> COMMA array_literal .)


state 105

    (44) expression_binary_operation -> expression PLUS expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    PLUS            reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    MINUS           reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    AND             reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    OR              reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    LT              reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    GT              reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    LE              reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    GE              reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    EQ              reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    NEQ             reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    COMMA           reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    ID              reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    NOT             reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    LBRACE          reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    INT_LITERAL     reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    FLOAT_LITERAL   reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    STRING_LITERAL  reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    BOOLEAN_LITERAL reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    RBRACE          reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    RPAREN          reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    RBRACKET        reduce using rule 44 (expression_binary_operation -> expression PLUS expression .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! TIMES           [ reduce using rule 44 (expression_binary_operation -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression_binary_operation -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 44 (expression_binary_operation -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 106

    (45) expression_binary_operation -> expression MINUS expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    PLUS            reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    MINUS           reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    AND             reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    OR              reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    LT              reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    GT              reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    LE              reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    GE              reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    EQ              reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    NEQ             reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    COMMA           reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    ID              reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    NOT             reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    LBRACE          reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    INT_LITERAL     reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    FLOAT_LITERAL   reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    STRING_LITERAL  reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    BOOLEAN_LITERAL reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    RBRACE          reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    RPAREN          reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    RBRACKET        reduce using rule 45 (expression_binary_operation -> expression MINUS expression .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! TIMES           [ reduce using rule 45 (expression_binary_operation -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 45 (expression_binary_operation -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 45 (expression_binary_operation -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 107

    (46) expression_binary_operation -> expression TIMES expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    PLUS            reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    MINUS           reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    TIMES           reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    DIVIDE          reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    MOD             reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    AND             reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    OR              reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    LT              reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    GT              reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    LE              reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    GE              reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    EQ              reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    NEQ             reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    COMMA           reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    ID              reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    NOT             reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    LBRACE          reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    INT_LITERAL     reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    FLOAT_LITERAL   reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    STRING_LITERAL  reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    BOOLEAN_LITERAL reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    RBRACE          reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    RPAREN          reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)
    RBRACKET        reduce using rule 46 (expression_binary_operation -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 80 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! MOD             [ shift and go to state 82 ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 108

    (47) expression_binary_operation -> expression DIVIDE expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    PLUS            reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    MINUS           reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    TIMES           reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    MOD             reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    AND             reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    OR              reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    LT              reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    GT              reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    LE              reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    GE              reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    EQ              reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    NEQ             reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    COMMA           reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    ID              reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    NOT             reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    LBRACE          reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    INT_LITERAL     reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    FLOAT_LITERAL   reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    STRING_LITERAL  reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    BOOLEAN_LITERAL reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    RBRACE          reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    RPAREN          reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 47 (expression_binary_operation -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 80 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! MOD             [ shift and go to state 82 ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 109

    (48) expression_binary_operation -> expression MOD expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    PLUS            reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    MINUS           reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    TIMES           reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    DIVIDE          reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    MOD             reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    AND             reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    OR              reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    LT              reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    GT              reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    LE              reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    GE              reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    EQ              reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    NEQ             reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    COMMA           reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    ID              reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    NOT             reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    LBRACE          reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    INT_LITERAL     reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    FLOAT_LITERAL   reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    STRING_LITERAL  reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    BOOLEAN_LITERAL reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    RBRACE          reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    RPAREN          reduce using rule 48 (expression_binary_operation -> expression MOD expression .)
    RBRACKET        reduce using rule 48 (expression_binary_operation -> expression MOD expression .)

  ! PLUS            [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 80 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! MOD             [ shift and go to state 82 ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 110

    (49) expression_binary_operation -> expression AND expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    AND             reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    OR              reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    LT              reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    GT              reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    LE              reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    GE              reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    EQ              reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    NEQ             reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    COMMA           reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    ID              reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    NOT             reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    LBRACE          reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    INT_LITERAL     reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    FLOAT_LITERAL   reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    STRING_LITERAL  reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    BOOLEAN_LITERAL reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    RBRACE          reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    RPAREN          reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    RBRACKET        reduce using rule 49 (expression_binary_operation -> expression AND expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 49 (expression_binary_operation -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 49 (expression_binary_operation -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 49 (expression_binary_operation -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression_binary_operation -> expression AND expression .) ]
  ! MOD             [ reduce using rule 49 (expression_binary_operation -> expression AND expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 111

    (50) expression_binary_operation -> expression OR expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    AND             reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    OR              reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    LT              reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    GT              reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    LE              reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    GE              reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    EQ              reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    NEQ             reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    COMMA           reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    ID              reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    NOT             reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    LBRACE          reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    INT_LITERAL     reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    FLOAT_LITERAL   reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    STRING_LITERAL  reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    BOOLEAN_LITERAL reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    RBRACE          reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    RPAREN          reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    RBRACKET        reduce using rule 50 (expression_binary_operation -> expression OR expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 50 (expression_binary_operation -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 50 (expression_binary_operation -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 50 (expression_binary_operation -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 50 (expression_binary_operation -> expression OR expression .) ]
  ! MOD             [ reduce using rule 50 (expression_binary_operation -> expression OR expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 112

    (51) expression_binary_operation -> expression LT expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    AND             reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    OR              reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    LT              reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    GT              reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    LE              reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    GE              reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    EQ              reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    NEQ             reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    COMMA           reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    ID              reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    NOT             reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    LBRACE          reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    INT_LITERAL     reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    FLOAT_LITERAL   reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    STRING_LITERAL  reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    BOOLEAN_LITERAL reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    RBRACE          reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    RPAREN          reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    RBRACKET        reduce using rule 51 (expression_binary_operation -> expression LT expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 51 (expression_binary_operation -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 51 (expression_binary_operation -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 51 (expression_binary_operation -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 51 (expression_binary_operation -> expression LT expression .) ]
  ! MOD             [ reduce using rule 51 (expression_binary_operation -> expression LT expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 113

    (52) expression_binary_operation -> expression GT expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    AND             reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    OR              reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    LT              reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    GT              reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    LE              reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    GE              reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    EQ              reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    NEQ             reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    COMMA           reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    ID              reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    NOT             reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    LBRACE          reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    INT_LITERAL     reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    FLOAT_LITERAL   reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    STRING_LITERAL  reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    BOOLEAN_LITERAL reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    RBRACE          reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    RPAREN          reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    RBRACKET        reduce using rule 52 (expression_binary_operation -> expression GT expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 52 (expression_binary_operation -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 52 (expression_binary_operation -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 52 (expression_binary_operation -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 52 (expression_binary_operation -> expression GT expression .) ]
  ! MOD             [ reduce using rule 52 (expression_binary_operation -> expression GT expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 114

    (53) expression_binary_operation -> expression LE expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    AND             reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    OR              reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    LT              reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    GT              reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    LE              reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    GE              reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    EQ              reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    NEQ             reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    COMMA           reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    ID              reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    NOT             reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    LBRACE          reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    INT_LITERAL     reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    FLOAT_LITERAL   reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    STRING_LITERAL  reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    BOOLEAN_LITERAL reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    RBRACE          reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    RPAREN          reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    RBRACKET        reduce using rule 53 (expression_binary_operation -> expression LE expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 53 (expression_binary_operation -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 53 (expression_binary_operation -> expression LE expression .) ]
  ! TIMES           [ reduce using rule 53 (expression_binary_operation -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 53 (expression_binary_operation -> expression LE expression .) ]
  ! MOD             [ reduce using rule 53 (expression_binary_operation -> expression LE expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 115

    (54) expression_binary_operation -> expression GE expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    AND             reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    OR              reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    LT              reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    GT              reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    LE              reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    GE              reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    EQ              reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    NEQ             reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    COMMA           reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    ID              reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    NOT             reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    LBRACE          reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    INT_LITERAL     reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    FLOAT_LITERAL   reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    STRING_LITERAL  reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    BOOLEAN_LITERAL reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    RBRACE          reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    RPAREN          reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    RBRACKET        reduce using rule 54 (expression_binary_operation -> expression GE expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 54 (expression_binary_operation -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 54 (expression_binary_operation -> expression GE expression .) ]
  ! TIMES           [ reduce using rule 54 (expression_binary_operation -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression_binary_operation -> expression GE expression .) ]
  ! MOD             [ reduce using rule 54 (expression_binary_operation -> expression GE expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 116

    (55) expression_binary_operation -> expression EQ expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    AND             reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    OR              reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    LT              reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    GT              reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    LE              reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    GE              reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    EQ              reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    NEQ             reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    COMMA           reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    ID              reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    NOT             reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    LBRACE          reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    INT_LITERAL     reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    FLOAT_LITERAL   reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    STRING_LITERAL  reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    BOOLEAN_LITERAL reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    RBRACE          reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    RPAREN          reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    RBRACKET        reduce using rule 55 (expression_binary_operation -> expression EQ expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 55 (expression_binary_operation -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 55 (expression_binary_operation -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 55 (expression_binary_operation -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 55 (expression_binary_operation -> expression EQ expression .) ]
  ! MOD             [ reduce using rule 55 (expression_binary_operation -> expression EQ expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 117

    (56) expression_binary_operation -> expression NEQ expression .
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    AND             reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    OR              reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    LT              reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    GT              reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    LE              reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    GE              reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    EQ              reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    NEQ             reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    COMMA           reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    ID              reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    NOT             reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    LBRACE          reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    INT_LITERAL     reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    FLOAT_LITERAL   reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    STRING_LITERAL  reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    BOOLEAN_LITERAL reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    RBRACE          reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    RPAREN          reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    RBRACKET        reduce using rule 56 (expression_binary_operation -> expression NEQ expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82

  ! PLUS            [ reduce using rule 56 (expression_binary_operation -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 56 (expression_binary_operation -> expression NEQ expression .) ]
  ! TIMES           [ reduce using rule 56 (expression_binary_operation -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 56 (expression_binary_operation -> expression NEQ expression .) ]
  ! MOD             [ reduce using rule 56 (expression_binary_operation -> expression NEQ expression .) ]
  ! AND             [ shift and go to state 83 ]
  ! OR              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! NEQ             [ shift and go to state 90 ]


state 118

    (24) return_statement -> RETURN ret_value SEMI .

    RETURN          reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    IF              reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    WHILE           reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    ID              reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    NOT             reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    LBRACE          reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    INT_LITERAL     reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    FLOAT_LITERAL   reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    STRING_LITERAL  reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    BOOLEAN_LITERAL reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)
    RBRACE          reduce using rule 24 (return_statement -> RETURN ret_value SEMI .)


state 119

    (27) if_statement -> IF expression block . else_statement
    (28) else_statement -> . ELSE block
    (29) else_statement -> . empty
    (74) empty -> .

    ELSE            shift and go to state 129
    RETURN          reduce using rule 74 (empty -> .)
    IF              reduce using rule 74 (empty -> .)
    WHILE           reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    NOT             reduce using rule 74 (empty -> .)
    LBRACE          reduce using rule 74 (empty -> .)
    INT_LITERAL     reduce using rule 74 (empty -> .)
    FLOAT_LITERAL   reduce using rule 74 (empty -> .)
    STRING_LITERAL  reduce using rule 74 (empty -> .)
    BOOLEAN_LITERAL reduce using rule 74 (empty -> .)
    RBRACE          reduce using rule 74 (empty -> .)

    else_statement                 shift and go to state 128
    empty                          shift and go to state 130

state 120

    (30) while_statement -> WHILE expression block .

    RETURN          reduce using rule 30 (while_statement -> WHILE expression block .)
    IF              reduce using rule 30 (while_statement -> WHILE expression block .)
    WHILE           reduce using rule 30 (while_statement -> WHILE expression block .)
    ID              reduce using rule 30 (while_statement -> WHILE expression block .)
    NOT             reduce using rule 30 (while_statement -> WHILE expression block .)
    LBRACE          reduce using rule 30 (while_statement -> WHILE expression block .)
    INT_LITERAL     reduce using rule 30 (while_statement -> WHILE expression block .)
    FLOAT_LITERAL   reduce using rule 30 (while_statement -> WHILE expression block .)
    STRING_LITERAL  reduce using rule 30 (while_statement -> WHILE expression block .)
    BOOLEAN_LITERAL reduce using rule 30 (while_statement -> WHILE expression block .)
    RBRACE          reduce using rule 30 (while_statement -> WHILE expression block .)


state 121

    (31) variable_declaration -> ID COLON var_type . EQUALS expression SEMI

    EQUALS          shift and go to state 131


state 122

    (32) variable_assignment -> ID EQUALS expression . SEMI
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            shift and go to state 132
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 123

    (67) function_invocation -> ID LPAREN func_invocation_args . RPAREN
    (73) index_access_aux -> LPAREN func_invocation_args . RPAREN LBRACKET expression RBRACKET

    RPAREN          shift and go to state 133


state 124

    (68) func_invocation_args -> expression . func_invocation_args
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression
    (68) func_invocation_args -> . expression func_invocation_args
    (69) func_invocation_args -> . COMMA func_invocation_args
    (70) func_invocation_args -> . empty
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (74) empty -> .
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    COMMA           shift and go to state 125
    RPAREN          reduce using rule 74 (empty -> .)
    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 124
    func_invocation_args           shift and go to state 134
    empty                          shift and go to state 126
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 125

    (69) func_invocation_args -> COMMA . func_invocation_args
    (68) func_invocation_args -> . expression func_invocation_args
    (69) func_invocation_args -> . COMMA func_invocation_args
    (70) func_invocation_args -> . empty
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (74) empty -> .
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    COMMA           shift and go to state 125
    RPAREN          reduce using rule 74 (empty -> .)
    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    func_invocation_args           shift and go to state 135
    expression                     shift and go to state 124
    empty                          shift and go to state 126
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 126

    (70) func_invocation_args -> empty .

    RPAREN          reduce using rule 70 (func_invocation_args -> empty .)


state 127

    (72) index_access_aux -> LBRACKET expression . RBRACKET
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    RBRACKET        shift and go to state 136
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 128

    (27) if_statement -> IF expression block else_statement .

    RETURN          reduce using rule 27 (if_statement -> IF expression block else_statement .)
    IF              reduce using rule 27 (if_statement -> IF expression block else_statement .)
    WHILE           reduce using rule 27 (if_statement -> IF expression block else_statement .)
    ID              reduce using rule 27 (if_statement -> IF expression block else_statement .)
    NOT             reduce using rule 27 (if_statement -> IF expression block else_statement .)
    LBRACE          reduce using rule 27 (if_statement -> IF expression block else_statement .)
    INT_LITERAL     reduce using rule 27 (if_statement -> IF expression block else_statement .)
    FLOAT_LITERAL   reduce using rule 27 (if_statement -> IF expression block else_statement .)
    STRING_LITERAL  reduce using rule 27 (if_statement -> IF expression block else_statement .)
    BOOLEAN_LITERAL reduce using rule 27 (if_statement -> IF expression block else_statement .)
    RBRACE          reduce using rule 27 (if_statement -> IF expression block else_statement .)


state 129

    (28) else_statement -> ELSE . block
    (15) block -> . LBRACE recursive_statement RBRACE

    LBRACE          shift and go to state 43

    block                          shift and go to state 137

state 130

    (29) else_statement -> empty .

    RETURN          reduce using rule 29 (else_statement -> empty .)
    IF              reduce using rule 29 (else_statement -> empty .)
    WHILE           reduce using rule 29 (else_statement -> empty .)
    ID              reduce using rule 29 (else_statement -> empty .)
    NOT             reduce using rule 29 (else_statement -> empty .)
    LBRACE          reduce using rule 29 (else_statement -> empty .)
    INT_LITERAL     reduce using rule 29 (else_statement -> empty .)
    FLOAT_LITERAL   reduce using rule 29 (else_statement -> empty .)
    STRING_LITERAL  reduce using rule 29 (else_statement -> empty .)
    BOOLEAN_LITERAL reduce using rule 29 (else_statement -> empty .)
    RBRACE          reduce using rule 29 (else_statement -> empty .)


state 131

    (31) variable_declaration -> ID COLON var_type EQUALS . expression SEMI
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 138
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 132

    (32) variable_assignment -> ID EQUALS expression SEMI .

    RETURN          reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    IF              reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    WHILE           reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    ID              reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    NOT             reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    LBRACE          reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    INT_LITERAL     reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    FLOAT_LITERAL   reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    STRING_LITERAL  reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    BOOLEAN_LITERAL reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)
    RBRACE          reduce using rule 32 (variable_assignment -> ID EQUALS expression SEMI .)


state 133

    (67) function_invocation -> ID LPAREN func_invocation_args RPAREN .
    (73) index_access_aux -> LPAREN func_invocation_args RPAREN . LBRACKET expression RBRACKET

    SEMI            reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    PLUS            reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    MINUS           reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    TIMES           reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    DIVIDE          reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    MOD             reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    AND             reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    OR              reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LT              reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    GT              reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LE              reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    GE              reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    EQ              reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    NEQ             reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    COMMA           reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    ID              reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    NOT             reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LBRACE          reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    INT_LITERAL     reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    FLOAT_LITERAL   reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    STRING_LITERAL  reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    BOOLEAN_LITERAL reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    RBRACE          reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    RPAREN          reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    RBRACKET        reduce using rule 67 (function_invocation -> ID LPAREN func_invocation_args RPAREN .)
    LBRACKET        shift and go to state 139


state 134

    (68) func_invocation_args -> expression func_invocation_args .

    RPAREN          reduce using rule 68 (func_invocation_args -> expression func_invocation_args .)


state 135

    (69) func_invocation_args -> COMMA func_invocation_args .

    RPAREN          reduce using rule 69 (func_invocation_args -> COMMA func_invocation_args .)


state 136

    (72) index_access_aux -> LBRACKET expression RBRACKET .

    SEMI            reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    MOD             reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    AND             reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    OR              reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    LT              reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    GT              reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    LE              reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    GE              reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    EQ              reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    ID              reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    NOT             reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    INT_LITERAL     reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    FLOAT_LITERAL   reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    STRING_LITERAL  reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    BOOLEAN_LITERAL reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 72 (index_access_aux -> LBRACKET expression RBRACKET .)


state 137

    (28) else_statement -> ELSE block .

    RETURN          reduce using rule 28 (else_statement -> ELSE block .)
    IF              reduce using rule 28 (else_statement -> ELSE block .)
    WHILE           reduce using rule 28 (else_statement -> ELSE block .)
    ID              reduce using rule 28 (else_statement -> ELSE block .)
    NOT             reduce using rule 28 (else_statement -> ELSE block .)
    LBRACE          reduce using rule 28 (else_statement -> ELSE block .)
    INT_LITERAL     reduce using rule 28 (else_statement -> ELSE block .)
    FLOAT_LITERAL   reduce using rule 28 (else_statement -> ELSE block .)
    STRING_LITERAL  reduce using rule 28 (else_statement -> ELSE block .)
    BOOLEAN_LITERAL reduce using rule 28 (else_statement -> ELSE block .)
    RBRACE          reduce using rule 28 (else_statement -> ELSE block .)


state 138

    (31) variable_declaration -> ID COLON var_type EQUALS expression . SEMI
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    SEMI            shift and go to state 140
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 139

    (73) index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET . expression RBRACKET
    (38) expression -> . expression_binary_operation
    (39) expression -> . expression_variable
    (40) expression -> . expression_unary_operation
    (41) expression -> . expression_literal
    (42) expression -> . function_invocation
    (43) expression -> . index_access
    (44) expression_binary_operation -> . expression PLUS expression
    (45) expression_binary_operation -> . expression MINUS expression
    (46) expression_binary_operation -> . expression TIMES expression
    (47) expression_binary_operation -> . expression DIVIDE expression
    (48) expression_binary_operation -> . expression MOD expression
    (49) expression_binary_operation -> . expression AND expression
    (50) expression_binary_operation -> . expression OR expression
    (51) expression_binary_operation -> . expression LT expression
    (52) expression_binary_operation -> . expression GT expression
    (53) expression_binary_operation -> . expression LE expression
    (54) expression_binary_operation -> . expression GE expression
    (55) expression_binary_operation -> . expression EQ expression
    (56) expression_binary_operation -> . expression NEQ expression
    (57) expression_variable -> . ID
    (58) expression_unary_operation -> . NOT expression
    (59) expression_literal -> . LBRACE array_literal RBRACE
    (60) expression_literal -> . INT_LITERAL
    (61) expression_literal -> . FLOAT_LITERAL
    (62) expression_literal -> . STRING_LITERAL
    (63) expression_literal -> . BOOLEAN_LITERAL
    (67) function_invocation -> . ID LPAREN func_invocation_args RPAREN
    (71) index_access -> . ID index_access_aux

    ID              shift and go to state 74
    NOT             shift and go to state 65
    LBRACE          shift and go to state 45
    INT_LITERAL     shift and go to state 66
    FLOAT_LITERAL   shift and go to state 67
    STRING_LITERAL  shift and go to state 68
    BOOLEAN_LITERAL shift and go to state 69

    expression                     shift and go to state 141
    expression_binary_operation    shift and go to state 56
    expression_variable            shift and go to state 57
    expression_unary_operation     shift and go to state 58
    expression_literal             shift and go to state 59
    function_invocation            shift and go to state 60
    index_access                   shift and go to state 61

state 140

    (31) variable_declaration -> ID COLON var_type EQUALS expression SEMI .

    RETURN          reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    IF              reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    WHILE           reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    ID              reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    NOT             reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    LBRACE          reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    INT_LITERAL     reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    FLOAT_LITERAL   reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    STRING_LITERAL  reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    BOOLEAN_LITERAL reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)
    RBRACE          reduce using rule 31 (variable_declaration -> ID COLON var_type EQUALS expression SEMI .)


state 141

    (73) index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression . RBRACKET
    (44) expression_binary_operation -> expression . PLUS expression
    (45) expression_binary_operation -> expression . MINUS expression
    (46) expression_binary_operation -> expression . TIMES expression
    (47) expression_binary_operation -> expression . DIVIDE expression
    (48) expression_binary_operation -> expression . MOD expression
    (49) expression_binary_operation -> expression . AND expression
    (50) expression_binary_operation -> expression . OR expression
    (51) expression_binary_operation -> expression . LT expression
    (52) expression_binary_operation -> expression . GT expression
    (53) expression_binary_operation -> expression . LE expression
    (54) expression_binary_operation -> expression . GE expression
    (55) expression_binary_operation -> expression . EQ expression
    (56) expression_binary_operation -> expression . NEQ expression

    RBRACKET        shift and go to state 142
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 82
    AND             shift and go to state 83
    OR              shift and go to state 84
    LT              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 142

    (73) index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .

    SEMI            reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    MOD             reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    AND             reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    OR              reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    LT              reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    GT              reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    LE              reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    GE              reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    EQ              reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    ID              reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    NOT             reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    INT_LITERAL     reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    FLOAT_LITERAL   reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    STRING_LITERAL  reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    BOOLEAN_LITERAL reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 73 (index_access_aux -> LPAREN func_invocation_args RPAREN LBRACKET expression RBRACKET .)

